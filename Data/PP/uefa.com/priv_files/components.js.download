/*!
 * jQuery UI Core 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// prevent duplicate loading
// this is only a problem because we proxy existing functions
// and we don't want to double proxy them
$.ui = $.ui || {};
if ( $.ui.version ) {
	return;
}

$.extend( $.ui, {
	version: "1.9.2",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	_focus: $.fn.focus,
	focus: function( delay, fn ) {
		return typeof delay === "number" ?
			this.each(function() {
				var elem = this;
				setTimeout(function() {
					$( elem ).focus();
					if ( fn ) {
						fn.call( elem );
					}
				}, delay );
			}) :
			this._focus.apply( this, arguments );
	},

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css('position'))) || (/absolute/).test(this.css('position'))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,'position')) && (/(auto|scroll)/).test($.css(this,'overflow')+$.css(this,'overflow-y')+$.css(this,'overflow-x'));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,'overflow')+$.css(this,'overflow-y')+$.css(this,'overflow-x'));
			}).eq(0);
		}

		return (/fixed/).test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().andSelf().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support
$(function() {
	var body = document.body,
		div = body.appendChild( div = document.createElement( "div" ) );

	// access offsetHeight before setting the style to prevent a layout bug
	// in IE 9 which causes the element to continue to take up space even
	// after it is removed from the DOM (#8026)
	div.offsetHeight;

	$.extend( div.style, {
		minHeight: "100px",
		height: "auto",
		padding: 0,
		borderWidth: 0
	});

	$.support.minHeight = div.offsetHeight === 100;
	$.support.selectstart = "onselectstart" in div;

	// set display to none to avoid a layout bug in IE
	// http://dev.jquery.com/ticket/4014
	body.removeChild( div ).style.display = "none";
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated

(function() {
	var uaMatch = /msie ([\w.]+)/.exec( navigator.userAgent.toLowerCase() ) || [];
	$.ui.ie = uaMatch.length ? true : false;
	$.ui.ie6 = parseFloat( uaMatch[ 1 ], 10 ) === 6;
})();

$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated.  Use the proxy pattern instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	contains: $.contains,

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	},

	// these are odd functions, fix the API or move into individual plugins
	isOverAxis: function( x, reference, size ) {
		//Determines when x coordinate is over "b" element axis
		return ( x > reference ) && ( x < ( reference + size ) );
	},
	isOver: function( y, x, top, left, height, width ) {
		//Determines when x, y coordinates is over "b" element
		return $.ui.isOverAxis( y, top, height ) && $.ui.isOverAxis( x, left, width );
	}
});

})( jQuery );

;/*!
 * jQuery UI Widget 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( $.isFunction( value ) ) {
			prototype[ prop ] = (function() {
				var _super = function() {
						return base.prototype[ prop ].apply( this, arguments );
					},
					_superApply = function( args ) {
						return base.prototype[ prop ].apply( this, args );
					};
				return function() {
					var __super = this._super,
						__superApply = this._superApply,
						returnValue;

					this._super = _super;
					this._superApply = _superApply;

					returnValue = value.apply( this, arguments );

					this._super = __super;
					this._superApply = __superApply;

					return returnValue;
				};
			})();
		}
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
	}, prototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		// TODO remove widgetBaseClass, see #8155
		widgetBaseClass: fullName,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			// 1.9 BC for #7810
			// TODO remove dual storage
			$.data( element, this.widgetName, this );
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( value === undefined ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( value === undefined ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && ( $.effects.effect[ effectName ] || $.uiBackCompat !== false && $.effects[ effectName ] ) ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

// DEPRECATED
if ( $.uiBackCompat !== false ) {
	$.Widget.prototype._getCreateOptions = function() {
		return $.metadata && $.metadata.get( this.element[0] )[ this.widgetName ];
	};
}

})( jQuery );

;/*!
 * jQuery UI Effects 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/effects-core/
 */
;(jQuery.effects || (function($, undefined) {

var backCompat = $.uiBackCompat !== false,
	// prefix used for storing data on .data()
	dataSpace = "ui-effects-";

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.0.0
 * http://jquery.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Mon Aug 13 13:41:02 2012 -0500
 */
(function( jQuery, undefined ) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor".split(" "),

	// plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	// a set of RE's that can match strings and generate color tuples.
	stringParsers = [{
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		}],

	// jQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// element for support tests
	supportElem = jQuery( "<p>" )[ 0 ],

	// colors = jQuery.Color.names
	colors,

	// local aliases of functions called often
	each = jQuery.each;

// determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = "_" + spaceName;
	space.props.alpha = {
		idx: 3,
		type: "percent",
		def: 1
	};
});

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return (allowEmpty || !prop.def) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {
		// we add mod before modding to make sure that negatives values
		// get converted properly: -10 -> 350
		return (value + type.mod) % type.mod;
	}

	// for now all property types without mod have min and max
	return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match && parser.parse( match ),
			spaceName = parser.space || "rgba";

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// if this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// exit each( stringParsers ) here because we matched
			return false;
		}
	});

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// if this came from a parsed string, force "transparent" when alpha is 0
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
		if ( rgba.join() === "0,0,0,0" ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// more than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = "array";
		}

		if ( type === "string" ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === "array" ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			});
			return this;
		}

		if ( type === "object" ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				});
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// if the cache doesn't exist, and we know how to convert
						if ( !inst[ cache ] && space.to ) {

							// if the value was null, we don't need to copy it
							// if the key was alpha, we don't need to copy it either
							if ( key === "alpha" || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// this is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					});

					// everything defined but alpha?
					if ( inst[ cache ] && $.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
						// use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				});
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if (isCache) {
				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				});
			}
			return same;
		});
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		});
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( "transparent" ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// if null, don't override start value
			if ( endValue === null ) {
				return;
			}
			// if null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue > type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue > type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		});
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {
		// if we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		}));
	},
	toRgbaString: function() {
		var prefix = "rgba(",
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i > 2 ? 1 : 0 ) : v;
			});

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = "rgb(";
		}

		return prefix + rgba.join() + ")";
	},
	toHslaString: function() {
		var prefix = "hsla(",
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i > 2 ? 1 : 0;
				}

				// catch 1 and 2
				if ( i && i < 3 ) {
					v = Math.round( v * 100 ) + "%";
				}
				return v;
			});

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = "hsl(";
		}
		return prefix + hsla.join() + ")";
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return "#" + jQuery.map( rgba, function( v ) {

			// default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? "0" + v : v;
		}).join("");
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
	}
});
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 < 1 ) {
		return p + (q - p) * h * 6;
	}
	if ( h * 2 < 1) {
		return q;
	}
	if ( h * 3 < 2 ) {
		return p + (q - p) * ((2/3) - h) * 6;
	}
	return p;
}

spaces.hsla.to = function ( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	if ( l === 0 || l === 1 ) {
		s = l;
	} else if ( l <= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function ( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};


each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// generate a cache for this space if it doesn't exist
		if ( to && !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === "array" || type === "object" ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === "object" ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		});

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {
		// alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === "undefined" ) {
				return cur;
			}

			if ( vtype === "function" ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null && prop.empty ) {
				return this;
			}
			if ( vtype === "string" ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	});
});

// add .fx.step functions
each( stepHooks, function( i, hook ) {
	jQuery.cssHooks[ hook ] = {
		set: function( elem, value ) {
			var parsed, curElem,
				backgroundColor = "";

			if ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) {
				value = color( parsed || value );
				if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
					curElem = hook === "backgroundColor" ? elem.parentNode : elem;
					while (
						(backgroundColor === "" || backgroundColor === "transparent") &&
						curElem && curElem.style
					) {
						try {
							backgroundColor = jQuery.css( curElem, "backgroundColor" );
							curElem = curElem.parentNode;
						} catch ( e ) {
						}
					}

					value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
						backgroundColor :
						"_default" );
				}

				value = value.toRgbaString();
			}
			try {
				elem.style[ hook ] = value;
			} catch( error ) {
				// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
			}
		}
	};
	jQuery.fx.step[ hook ] = function( fx ) {
		if ( !fx.colorInit ) {
			fx.start = color( fx.elem, hook );
			fx.end = color( fx.end );
			fx.colorInit = true;
		}
		jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
	};
});

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
			expanded[ "border" + part + "Color" ] = value;
		});
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {
	// 4.1. Basic color keywords
	aqua: "#00ffff",
	black: "#000000",
	blue: "#0000ff",
	fuchsia: "#ff00ff",
	gray: "#808080",
	green: "#008000",
	lime: "#00ff00",
	maroon: "#800000",
	navy: "#000080",
	olive: "#808000",
	purple: "#800080",
	red: "#ff0000",
	silver: "#c0c0c0",
	teal: "#008080",
	white: "#ffffff",
	yellow: "#ffff00",

	// 4.2.3. "transparent" color keyword
	transparent: [ null, null, null, 0 ],

	_default: "#ffffff"
};

})( jQuery );



/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
(function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
	$.fx.step[ prop ] = function( fx ) {
		if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
			jQuery.style( fx.elem, prop, fx.end );
			fx.setAttr = true;
		}
	};
});

function getElementStyles() {
	var style = this.ownerDocument.defaultView ?
			this.ownerDocument.defaultView.getComputedStyle( this, null ) :
			this.currentStyle,
		newStyle = {},
		key,
		len;

	// webkit enumerates style porperties
	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === "string" ) {
				newStyle[ $.camelCase( key ) ] = style[ key ];
			}
		}
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === "string" ) {
				newStyle[ key ] = style[ key ];
			}
		}
	}

	return newStyle;
}


function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( "class" ) || "",
			applyClassChange,
			allAnimations = o.children ? animated.find( "*" ).andSelf() : animated;

		// map the animated objects to store the original styles.
		allAnimations = allAnimations.map(function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles.call( this )
			};
		});

		// apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function(i, action) {
				if ( value[ action ] ) {
					animated[ action + "Class" ]( value[ action ] );
				}
			});
		};
		applyClassChange();

		// map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map(function() {
			this.end = getElementStyles.call( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		});

		// apply original class
		animated.attr( "class", baseClass );

		// map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map(function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = jQuery.extend({}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				});

			this.el.animate( this.diff, opts );
			return dfd.promise();
		});

		// once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done(function() {

			// set the final class
			applyClassChange();

			// for each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function(key) {
					el.css( key, '' );
				});
			});

			// this is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		});
	});
};

$.fn.extend({
	_addClass: $.fn.addClass,
	addClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ add: classNames }, speed, easing, callback ) :
			this._addClass( classNames );
	},

	_removeClass: $.fn.removeClass,
	removeClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ remove: classNames }, speed, easing, callback ) :
			this._removeClass( classNames );
	},

	_toggleClass: $.fn.toggleClass,
	toggleClass: function( classNames, force, speed, easing, callback ) {
		if ( typeof force === "boolean" || force === undefined ) {
			if ( !speed ) {
				// without speed parameter
				return this._toggleClass( classNames, force );
			} else {
				return $.effects.animateClass.call( this,
					(force ? { add: classNames } : { remove: classNames }),
					speed, easing, callback );
			}
		} else {
			// without force parameter
			return $.effects.animateClass.call( this,
				{ toggle: classNames }, force, speed, easing );
		}
	},

	switchClass: function( remove, add, speed, easing, callback) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
});

})();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

(function() {

$.extend( $.effects, {
	version: "1.9.2",

	// Saves a set of properties in a data storage
	save: function( element, set ) {
		for( var i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
			}
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function( element, set ) {
		var val, i;
		for( i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				val = element.data( dataSpace + set[ i ] );
				// support: jQuery 1.6.2
				// http://bugs.jquery.com/ticket/9917
				// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
				// We can't differentiate between "" and 0 here, so we just assume
				// empty string since it's likely to be a more common value...
				if ( val === undefined ) {
					val = "";
				}
				element.css( set[ i ], val );
			}
		}
	},

	setMode: function( el, mode ) {
		if (mode === "toggle") {
			mode = el.is( ":hidden" ) ? "show" : "hide";
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	// this should be a little more flexible in the future to handle a string & hash
	getBaseline: function( origin, original ) {
		var y, x;
		switch ( origin[ 0 ] ) {
			case "top": y = 0; break;
			case "middle": y = 0.5; break;
			case "bottom": y = 1; break;
			default: y = origin[ 0 ] / original.height;
		}
		switch ( origin[ 1 ] ) {
			case "left": x = 0; break;
			case "center": x = 0.5; break;
			case "right": x = 1; break;
			default: x = origin[ 1 ] / original.width;
		}
		return {
			x: x,
			y: y
		};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function( element ) {

		// if the element is already wrapped, return it
		if ( element.parent().is( ".ui-effects-wrapper" )) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				"float": element.css( "float" )
			},
			wrapper = $( "<div></div>" )
				.addClass( "ui-effects-wrapper" )
				.css({
					fontSize: "100%",
					background: "transparent",
					border: "none",
					margin: 0,
					padding: 0
				}),
			// Store the size in case width/height are defined in % - Fixes #5245
			size = {
				width: element.width(),
				height: element.height()
			},
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}

		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if ( element.css( "position" ) === "static" ) {
			wrapper.css({ position: "relative" });
			element.css({ position: "relative" });
		} else {
			$.extend( props, {
				position: element.css( "position" ),
				zIndex: element.css( "z-index" )
			});
			$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
				props[ pos ] = element.css( pos );
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
					props[ pos ] = "auto";
				}
			});
			element.css({
				position: "relative",
				top: 0,
				left: 0,
				right: "auto",
				bottom: "auto"
			});
		}
		element.css(size);

		return wrapper.css( props ).show();
	},

	removeWrapper: function( element ) {
		var active = document.activeElement;

		if ( element.parent().is( ".ui-effects-wrapper" ) ) {
			element.parent().replaceWith( element );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
		}


		return element;
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] > 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		});
		return value;
	}
});

// return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// convert to an object
	effect = { effect: effect };

	// catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// catch (effect, speed, ?)
	if ( typeof options === "number" || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === "number" ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardSpeed( speed ) {
	// valid standard speeds
	if ( !speed || typeof speed === "number" || $.fx.speeds[ speed ] ) {
		return true;
	}

	// invalid strings - treat as "normal" speed
	if ( typeof speed === "string" && !$.effects.effect[ speed ] ) {
		// TODO: remove in 2.0 (#7115)
		if ( backCompat && $.effects[ speed ] ) {
			return false;
		}
		return true;
	}

	return false;
}

$.fn.extend({
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			mode = args.mode,
			queue = args.queue,
			effectMethod = $.effects.effect[ args.effect ],

			// DEPRECATED: remove in 2.0 (#7115)
			oldEffectMethod = !effectMethod && backCompat && $.effects[ args.effect ];

		if ( $.fx.off || !( effectMethod || oldEffectMethod ) ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, args.complete );
			} else {
				return this.each( function() {
					if ( args.complete ) {
						args.complete.call( this );
					}
				});
			}
		}

		function run( next ) {
			var elem = $( this ),
				complete = args.complete,
				mode = args.mode;

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[0] );
				}
				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// if the element is hiddden and mode is hide,
			// or element is visible and mode is show
			if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
				done();
			} else {
				effectMethod.call( elem[0], args, done );
			}
		}

		// TODO: remove this check in 2.0, effectMethod will always be true
		if ( effectMethod ) {
			return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
		} else {
			// DEPRECATED: remove in 2.0 (#7115)
			return oldEffectMethod.call(this, {
				options: args,
				duration: args.duration,
				callback: args.complete,
				mode: args.mode
			});
		}
	},

	_show: $.fn.show,
	show: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._show.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "show";
			return this.effect.call( this, args );
		}
	},

	_hide: $.fn.hide,
	hide: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._hide.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "hide";
			return this.effect.call( this, args );
		}
	},

	// jQuery core overloads toggle and creates _toggle
	__toggle: $.fn.toggle,
	toggle: function( speed ) {
		if ( standardSpeed( speed ) || typeof speed === "boolean" || $.isFunction( speed ) ) {
			return this.__toggle.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "toggle";
			return this.effect.call( this, args );
		}
	},

	// helper functions
	cssUnit: function(key) {
		var style = this.css( key ),
			val = [];

		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
			if ( style.indexOf( unit ) > 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		});
		return val;
	}
});

})();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

(function() {

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function ( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function ( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function ( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
});

})();

})(jQuery));

;/*!
 * jQuery UI Tabs 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/tabs/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var tabId = 0,
	rhash = /#.*$/;

function getNextTabId() {
	return ++tabId;
}

function isLocal( anchor ) {
	return anchor.hash.length > 1 &&
		anchor.href.replace( rhash, "" ) ===
			location.href.replace( rhash, "" )
				// support: Safari 5.1
				// Safari 5.1 doesn't encode spaces in window.location
				// but it does encode spaces from anchors (#8777)
				.replace( /\s/g, "%20" );
}

$.widget( "ui.tabs", {
	version: "1.9.2",
	delay: 300,
	options: {
		active: null,
		collapsible: false,
		event: "click",
		heightStyle: "content",
		hide: null,
		show: null,

		// callbacks
		activate: null,
		beforeActivate: null,
		beforeLoad: null,
		load: null
	},

	_create: function() {
		var that = this,
			options = this.options,
			active = options.active,
			locationHash = location.hash.substring( 1 );

		this.running = false;

		this.element
			.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
			.toggleClass( "ui-tabs-collapsible", options.collapsible )
			// Prevent users from focusing disabled tabs via click
			.delegate( ".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function( event ) {
				if ( $( this ).is( ".ui-state-disabled" ) ) {
					event.preventDefault();
				}
			})
			// support: IE <9
			// Preventing the default action in mousedown doesn't prevent IE
			// from focusing the element, so if the anchor gets focused, blur.
			// We don't have to worry about focusing the previously focused
			// element since clicking on a non-focusable element should focus
			// the body anyway.
			.delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
				if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
					this.blur();
				}
			});

		this._processTabs();

		if ( active === null ) {
			// check the fragment identifier in the URL
			if ( locationHash ) {
				this.tabs.each(function( i, tab ) {
					if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
						active = i;
						return false;
					}
				});
			}

			// check for a tab marked active via a class
			if ( active === null ) {
				active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
			}

			// no active tab, set to false
			if ( active === null || active === -1 ) {
				active = this.tabs.length ? 0 : false;
			}
		}

		// handle numbers: negative, out of range
		if ( active !== false ) {
			active = this.tabs.index( this.tabs.eq( active ) );
			if ( active === -1 ) {
				active = options.collapsible ? false : 0;
			}
		}
		options.active = active;

		// don't allow collapsible: false and active: false
		if ( !options.collapsible && options.active === false && this.anchors.length ) {
			options.active = 0;
		}

		// Take disabling tabs via class attribute from HTML
		// into account and update option properly.
		if ( $.isArray( options.disabled ) ) {
			options.disabled = $.unique( options.disabled.concat(
				$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
					return that.tabs.index( li );
				})
			) ).sort();
		}

		// check for length avoids error when initializing empty list
		if ( this.options.active !== false && this.anchors.length ) {
			this.active = this._findActive( this.options.active );
		} else {
			this.active = $();
		}

		this._refresh();

		if ( this.active.length ) {
			this.load( options.active );
		}
	},

	_getCreateEventData: function() {
		return {
			tab: this.active,
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )
		};
	},

	_tabKeydown: function( event ) {
		var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
			selectedIndex = this.tabs.index( focusedTab ),
			goingForward = true;

		if ( this._handlePageNav( event ) ) {
			return;
		}

		switch ( event.keyCode ) {
			case $.ui.keyCode.RIGHT:
			case $.ui.keyCode.DOWN:
				selectedIndex++;
				break;
			case $.ui.keyCode.UP:
			case $.ui.keyCode.LEFT:
				goingForward = false;
				selectedIndex--;
				break;
			case $.ui.keyCode.END:
				selectedIndex = this.anchors.length - 1;
				break;
			case $.ui.keyCode.HOME:
				selectedIndex = 0;
				break;
			case $.ui.keyCode.SPACE:
				// Activate only, no collapsing
				event.preventDefault();
				clearTimeout( this.activating );
				this._activate( selectedIndex );
				return;
			case $.ui.keyCode.ENTER:
				// Toggle (cancel delayed activation, allow collapsing)
				event.preventDefault();
				clearTimeout( this.activating );
				// Determine if we should collapse or activate
				this._activate( selectedIndex === this.options.active ? false : selectedIndex );
				return;
			default:
				return;
		}

		// Focus the appropriate tab, based on which key was pressed
		event.preventDefault();
		clearTimeout( this.activating );
		selectedIndex = this._focusNextTab( selectedIndex, goingForward );

		// Navigating with control key will prevent automatic activation
		if ( !event.ctrlKey ) {
			// Update aria-selected immediately so that AT think the tab is already selected.
			// Otherwise AT may confuse the user by stating that they need to activate the tab,
			// but the tab will already be activated by the time the announcement finishes.
			focusedTab.attr( "aria-selected", "false" );
			this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

			this.activating = this._delay(function() {
				this.option( "active", selectedIndex );
			}, this.delay );
		}
	},

	_panelKeydown: function( event ) {
		if ( this._handlePageNav( event ) ) {
			return;
		}

		// Ctrl+up moves focus to the current tab
		if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
			event.preventDefault();
			this.active.focus();
		}
	},

	// Alt+page up/down moves focus to the previous/next tab (and activates)
	_handlePageNav: function( event ) {
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
			this._activate( this._focusNextTab( this.options.active - 1, false ) );
			return true;
		}
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
			this._activate( this._focusNextTab( this.options.active + 1, true ) );
			return true;
		}
	},

	_findNextTab: function( index, goingForward ) {
		var lastTabIndex = this.tabs.length - 1;

		function constrain() {
			if ( index > lastTabIndex ) {
				index = 0;
			}
			if ( index < 0 ) {
				index = lastTabIndex;
			}
			return index;
		}

		while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
			index = goingForward ? index + 1 : index - 1;
		}

		return index;
	},

	_focusNextTab: function( index, goingForward ) {
		index = this._findNextTab( index, goingForward );
		this.tabs.eq( index ).focus();
		return index;
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "disabled" ) {
			// don't use the widget factory's disabled handling
			this._setupDisabled( value );
			return;
		}

		this._super( key, value);

		if ( key === "collapsible" ) {
			this.element.toggleClass( "ui-tabs-collapsible", value );
			// Setting collapsible: false while collapsed; open first panel
			if ( !value && this.options.active === false ) {
				this._activate( 0 );
			}
		}

		if ( key === "event" ) {
			this._setupEvents( value );
		}

		if ( key === "heightStyle" ) {
			this._setupHeightStyle( value );
		}
	},

	_tabId: function( tab ) {
		return tab.attr( "aria-controls" ) || "ui-tabs-" + getNextTabId();
	},

	_sanitizeSelector: function( hash ) {
		return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
	},

	refresh: function() {
		var options = this.options,
			lis = this.tablist.children( ":has(a[href])" );

		// get disabled tabs from class attribute from HTML
		// this will get converted to a boolean if needed in _refresh()
		options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
			return lis.index( tab );
		});

		this._processTabs();

		// was collapsed or no tabs
		if ( options.active === false || !this.anchors.length ) {
			options.active = false;
			this.active = $();
		// was active, but active tab is gone
		} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
			// all remaining tabs are disabled
			if ( this.tabs.length === options.disabled.length ) {
				options.active = false;
				this.active = $();
			// activate previous tab
			} else {
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
			}
		// was active, active tab still exists
		} else {
			// make sure active index is correct
			options.active = this.tabs.index( this.active );
		}

		this._refresh();
	},

	_refresh: function() {
		this._setupDisabled( this.options.disabled );
		this._setupEvents( this.options.event );
		this._setupHeightStyle( this.options.heightStyle );

		this.tabs.not( this.active ).attr({
			"aria-selected": "false",
			tabIndex: -1
		});
		this.panels.not( this._getPanelForTab( this.active ) )
			.hide()
			.attr({
				"aria-expanded": "false",
				"aria-hidden": "true"
			});

		// Make sure one tab is in the tab order
		if ( !this.active.length ) {
			this.tabs.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active
				.addClass( "ui-tabs-active ui-state-active" )
				.attr({
					"aria-selected": "true",
					tabIndex: 0
				});
			this._getPanelForTab( this.active )
				.show()
				.attr({
					"aria-expanded": "true",
					"aria-hidden": "false"
				});
		}
	},

	_processTabs: function() {
		var that = this;

		this.tablist = this._getList()
			.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.attr( "role", "tablist" );

		this.tabs = this.tablist.find( "> li:has(a[href])" )
			.addClass( "ui-state-default ui-corner-top" )
			.attr({
				role: "tab",
				tabIndex: -1
			});

		this.anchors = this.tabs.map(function() {
				return $( "a", this )[ 0 ];
			})
			.addClass( "ui-tabs-anchor" )
			.attr({
				role: "presentation",
				tabIndex: -1
			});

		this.panels = $();

		this.anchors.each(function( i, anchor ) {
			var selector, panel, panelId,
				anchorId = $( anchor ).uniqueId().attr( "id" ),
				tab = $( anchor ).closest( "li" ),
				originalAriaControls = tab.attr( "aria-controls" );

			// inline tab
			if ( isLocal( anchor ) ) {
				selector = anchor.hash;
				panel = that.element.find( that._sanitizeSelector( selector ) );
			// remote tab
			} else {
				panelId = that._tabId( tab );
				selector = "#" + panelId;
				panel = that.element.find( selector );
				if ( !panel.length ) {
					panel = that._createPanel( panelId );
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
				}
				panel.attr( "aria-live", "polite" );
			}

			if ( panel.length) {
				that.panels = that.panels.add( panel );
			}
			if ( originalAriaControls ) {
				tab.data( "ui-tabs-aria-controls", originalAriaControls );
			}
			tab.attr({
				"aria-controls": selector.substring( 1 ),
				"aria-labelledby": anchorId
			});
			panel.attr( "aria-labelledby", anchorId );
		});

		this.panels
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.attr( "role", "tabpanel" );
	},

	// allow overriding how to find the list for rare usage scenarios (#7715)
	_getList: function() {
		return this.element.find( "ol,ul" ).eq( 0 );
	},

	_createPanel: function( id ) {
		return $( "<div>" )
			.attr( "id", id )
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.data( "ui-tabs-destroy", true );
	},

	_setupDisabled: function( disabled ) {
		if ( $.isArray( disabled ) ) {
			if ( !disabled.length ) {
				disabled = false;
			} else if ( disabled.length === this.anchors.length ) {
				disabled = true;
			}
		}

		// disable tabs
		for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
			if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
				$( li )
					.addClass( "ui-state-disabled" )
					.attr( "aria-disabled", "true" );
			} else {
				$( li )
					.removeClass( "ui-state-disabled" )
					.removeAttr( "aria-disabled" );
			}
		}

		this.options.disabled = disabled;
	},

	_setupEvents: function( event ) {
		var events = {
			click: function( event ) {
				event.preventDefault();
			}
		};
		if ( event ) {
			$.each( event.split(" "), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			});
		}

		this._off( this.anchors.add( this.tabs ).add( this.panels ) );
		this._on( this.anchors, events );
		this._on( this.tabs, { keydown: "_tabKeydown" } );
		this._on( this.panels, { keydown: "_panelKeydown" } );

		this._focusable( this.tabs );
		this._hoverable( this.tabs );
	},

	_setupHeightStyle: function( heightStyle ) {
		var maxHeight, overflow,
			parent = this.element.parent();

		if ( heightStyle === "fill" ) {
			// IE 6 treats height like minHeight, so we need to turn off overflow
			// in order to get a reliable height
			// we use the minHeight support test because we assume that only
			// browsers that don't support minHeight will treat height as minHeight
			if ( !$.support.minHeight ) {
				overflow = parent.css( "overflow" );
				parent.css( "overflow", "hidden");
			}
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});
			if ( overflow ) {
				parent.css( "overflow", overflow );
			}

			this.element.children().not( this.panels ).each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.panels.each(function() {
				$( this ).height( Math.max( 0, maxHeight -
					$( this ).innerHeight() + $( this ).height() ) );
			})
			.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.panels.each(function() {
				maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
			}).height( maxHeight );
		}
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			anchor = $( event.currentTarget ),
			tab = anchor.closest( "li" ),
			clickedIsActive = tab[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : this._getPanelForTab( tab ),
			toHide = !active.length ? $() : this._getPanelForTab( active ),
			eventData = {
				oldTab: active,
				oldPanel: toHide,
				newTab: collapsing ? $() : tab,
				newPanel: toShow
			};

		event.preventDefault();

		if ( tab.hasClass( "ui-state-disabled" ) ||
				// tab is already loading
				tab.hasClass( "ui-tabs-loading" ) ||
				// can't switch durning an animation
				this.running ||
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.tabs.index( tab );

		this.active = clickedIsActive ? $() : tab;
		if ( this.xhr ) {
			this.xhr.abort();
		}

		if ( !toHide.length && !toShow.length ) {
			$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
		}

		if ( toShow.length ) {
			this.load( this.tabs.index( tab ), event );
		}
		this._toggle( event, eventData );
	},

	// handles show/hide for selecting tabs
	_toggle: function( event, eventData ) {
		var that = this,
			toShow = eventData.newPanel,
			toHide = eventData.oldPanel;

		this.running = true;

		function complete() {
			that.running = false;
			that._trigger( "activate", event, eventData );
		}

		function show() {
			eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

			if ( toShow.length && that.options.show ) {
				that._show( toShow, that.options.show, complete );
			} else {
				toShow.show();
				complete();
			}
		}

		// start out by hiding, then showing, then completing
		if ( toHide.length && this.options.hide ) {
			this._hide( toHide, this.options.hide, function() {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				show();
			});
		} else {
			eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
			toHide.hide();
			show();
		}

		toHide.attr({
			"aria-expanded": "false",
			"aria-hidden": "true"
		});
		eventData.oldTab.attr( "aria-selected", "false" );
		// If we're switching tabs, remove the old tab from the tab order.
		// If we're opening from collapsed state, remove the previous tab from the tab order.
		// If we're collapsing, then keep the collapsing tab in the tab order.
		if ( toShow.length && toHide.length ) {
			eventData.oldTab.attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.tabs.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow.attr({
			"aria-expanded": "true",
			"aria-hidden": "false"
		});
		eventData.newTab.attr({
			"aria-selected": "true",
			tabIndex: 0
		});
	},

	_activate: function( index ) {
		var anchor,
			active = this._findActive( index );

		// trying to activate the already active panel
		if ( active[ 0 ] === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the current active header
		if ( !active.length ) {
			active = this.active;
		}

		anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
		this._eventHandler({
			target: anchor,
			currentTarget: anchor,
			preventDefault: $.noop
		});
	},

	_findActive: function( index ) {
		return index === false ? $() : this.tabs.eq( index );
	},

	_getIndex: function( index ) {
		// meta-function to give users option to provide a href string instead of a numerical index.
		if ( typeof index === "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
		}

		return index;
	},

	_destroy: function() {
		if ( this.xhr ) {
			this.xhr.abort();
		}

		this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );

		this.tablist
			.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.removeAttr( "role" );

		this.anchors
			.removeClass( "ui-tabs-anchor" )
			.removeAttr( "role" )
			.removeAttr( "tabIndex" )
			.removeData( "href.tabs" )
			.removeData( "load.tabs" )
			.removeUniqueId();

		this.tabs.add( this.panels ).each(function() {
			if ( $.data( this, "ui-tabs-destroy" ) ) {
				$( this ).remove();
			} else {
				$( this )
					.removeClass( "ui-state-default ui-state-active ui-state-disabled " +
						"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
					.removeAttr( "tabIndex" )
					.removeAttr( "aria-live" )
					.removeAttr( "aria-busy" )
					.removeAttr( "aria-selected" )
					.removeAttr( "aria-labelledby" )
					.removeAttr( "aria-hidden" )
					.removeAttr( "aria-expanded" )
					.removeAttr( "role" );
			}
		});

		this.tabs.each(function() {
			var li = $( this ),
				prev = li.data( "ui-tabs-aria-controls" );
			if ( prev ) {
				li.attr( "aria-controls", prev );
			} else {
				li.removeAttr( "aria-controls" );
			}
		});

		this.panels.show();

		if ( this.options.heightStyle !== "content" ) {
			this.panels.css( "height", "" );
		}
	},

	enable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === false ) {
			return;
		}

		if ( index === undefined ) {
			disabled = false;
		} else {
			index = this._getIndex( index );
			if ( $.isArray( disabled ) ) {
				disabled = $.map( disabled, function( num ) {
					return num !== index ? num : null;
				});
			} else {
				disabled = $.map( this.tabs, function( li, num ) {
					return num !== index ? num : null;
				});
			}
		}
		this._setupDisabled( disabled );
	},

	disable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === true ) {
			return;
		}

		if ( index === undefined ) {
			disabled = true;
		} else {
			index = this._getIndex( index );
			if ( $.inArray( index, disabled ) !== -1 ) {
				return;
			}
			if ( $.isArray( disabled ) ) {
				disabled = $.merge( [ index ], disabled ).sort();
			} else {
				disabled = [ index ];
			}
		}
		this._setupDisabled( disabled );
	},

	load: function( index, event ) {
		index = this._getIndex( index );
		var that = this,
			tab = this.tabs.eq( index ),
			anchor = tab.find( ".ui-tabs-anchor" ),
			panel = this._getPanelForTab( tab ),
			eventData = {
				tab: tab,
				panel: panel
			};

		// not remote
		if ( isLocal( anchor[ 0 ] ) ) {
			return;
		}

		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

		// support: jQuery <1.8
		// jQuery <1.8 returns false if the request is canceled in beforeSend,
		// but as of 1.8, $.ajax() always returns a jqXHR object.
		if ( this.xhr && this.xhr.statusText !== "canceled" ) {
			tab.addClass( "ui-tabs-loading" );
			panel.attr( "aria-busy", "true" );

			this.xhr
				.success(function( response ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						panel.html( response );
						that._trigger( "load", event, eventData );
					}, 1 );
				})
				.complete(function( jqXHR, status ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						if ( status === "abort" ) {
							that.panels.stop( false, true );
						}

						tab.removeClass( "ui-tabs-loading" );
						panel.removeAttr( "aria-busy" );

						if ( jqXHR === that.xhr ) {
							delete that.xhr;
						}
					}, 1 );
				});
		}
	},

	// TODO: Remove this function in 1.10 when ajaxOptions is removed
	_ajaxSettings: function( anchor, event, eventData ) {
		var that = this;
		return {
			url: anchor.attr( "href" ),
			beforeSend: function( jqXHR, settings ) {
				return that._trigger( "beforeLoad", event,
					$.extend( { jqXHR : jqXHR, ajaxSettings: settings }, eventData ) );
			}
		};
	},

	_getPanelForTab: function( tab ) {
		var id = $( tab ).attr( "aria-controls" );
		return this.element.find( this._sanitizeSelector( "#" + id ) );
	}
});

// DEPRECATED
if ( $.uiBackCompat !== false ) {

	// helper method for a lot of the back compat extensions
	$.ui.tabs.prototype._ui = function( tab, panel ) {
		return {
			tab: tab,
			panel: panel,
			index: this.anchors.index( tab )
		};
	};

	// url method
	$.widget( "ui.tabs", $.ui.tabs, {
		url: function( index, url ) {
			this.anchors.eq( index ).attr( "href", url );
		}
	});

	// TODO: Remove _ajaxSettings() method when removing this extension
	// ajaxOptions and cache options
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			ajaxOptions: null,
			cache: false
		},

		_create: function() {
			this._super();

			var that = this;

			this._on({ tabsbeforeload: function( event, ui ) {
				// tab is already cached
				if ( $.data( ui.tab[ 0 ], "cache.tabs" ) ) {
					event.preventDefault();
					return;
				}

				ui.jqXHR.success(function() {
					if ( that.options.cache ) {
						$.data( ui.tab[ 0 ], "cache.tabs", true );
					}
				});
			}});
		},

		_ajaxSettings: function( anchor, event, ui ) {
			var ajaxOptions = this.options.ajaxOptions;
			return $.extend( {}, ajaxOptions, {
				error: function( xhr, status ) {
					try {
						// Passing index avoid a race condition when this method is
						// called after the user has selected another tab.
						// Pass the anchor that initiated this request allows
						// loadError to manipulate the tab content panel via $(a.hash)
						ajaxOptions.error(
							xhr, status, ui.tab.closest( "li" ).index(), ui.tab[ 0 ] );
					}
					catch ( error ) {}
				}
			}, this._superApply( arguments ) );
		},

		_setOption: function( key, value ) {
			// reset cache if switching from cached to not cached
			if ( key === "cache" && value === false ) {
				this.anchors.removeData( "cache.tabs" );
			}
			this._super( key, value );
		},

		_destroy: function() {
			this.anchors.removeData( "cache.tabs" );
			this._super();
		},

		url: function( index ){
			this.anchors.eq( index ).removeData( "cache.tabs" );
			this._superApply( arguments );
		}
	});

	// abort method
	$.widget( "ui.tabs", $.ui.tabs, {
		abort: function() {
			if ( this.xhr ) {
				this.xhr.abort();
			}
		}
	});

	// spinner
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			spinner: "<em>Loading&#8230;</em>"
		},
		_create: function() {
			this._super();
			this._on({
				tabsbeforeload: function( event, ui ) {
					// Don't react to nested tabs or tabs that don't use a spinner
					if ( event.target !== this.element[ 0 ] ||
							!this.options.spinner ) {
						return;
					}

					var span = ui.tab.find( "span" ),
						html = span.html();
					span.html( this.options.spinner );
					ui.jqXHR.complete(function() {
						span.html( html );
					});
				}
			});
		}
	});

	// enable/disable events
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			enable: null,
			disable: null
		},

		enable: function( index ) {
			var options = this.options,
				trigger;

			if ( index && options.disabled === true ||
					( $.isArray( options.disabled ) && $.inArray( index, options.disabled ) !== -1 ) ) {
				trigger = true;
			}

			this._superApply( arguments );

			if ( trigger ) {
				this._trigger( "enable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
			}
		},

		disable: function( index ) {
			var options = this.options,
				trigger;

			if ( index && options.disabled === false ||
					( $.isArray( options.disabled ) && $.inArray( index, options.disabled ) === -1 ) ) {
				trigger = true;
			}

			this._superApply( arguments );

			if ( trigger ) {
				this._trigger( "disable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
			}
		}
	});

	// add/remove methods and events
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			add: null,
			remove: null,
			tabTemplate: "<li><a href='#{href}'><span>#{label}</span></a></li>"
		},

		add: function( url, label, index ) {
			if ( index === undefined ) {
				index = this.anchors.length;
			}

			var doInsertAfter, panel,
				options = this.options,
				li = $( options.tabTemplate
					.replace( /#\{href\}/g, url )
					.replace( /#\{label\}/g, label ) ),
				id = !url.indexOf( "#" ) ?
					url.replace( "#", "" ) :
					this._tabId( li );

			li.addClass( "ui-state-default ui-corner-top" ).data( "ui-tabs-destroy", true );
			li.attr( "aria-controls", id );

			doInsertAfter = index >= this.tabs.length;

			// try to find an existing element before creating a new one
			panel = this.element.find( "#" + id );
			if ( !panel.length ) {
				panel = this._createPanel( id );
				if ( doInsertAfter ) {
					if ( index > 0 ) {
						panel.insertAfter( this.panels.eq( -1 ) );
					} else {
						panel.appendTo( this.element );
					}
				} else {
					panel.insertBefore( this.panels[ index ] );
				}
			}
			panel.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" ).hide();

			if ( doInsertAfter ) {
				li.appendTo( this.tablist );
			} else {
				li.insertBefore( this.tabs[ index ] );
			}

			options.disabled = $.map( options.disabled, function( n ) {
				return n >= index ? ++n : n;
			});

			this.refresh();
			if ( this.tabs.length === 1 && options.active === false ) {
				this.option( "active", 0 );
			}

			this._trigger( "add", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
			return this;
		},

		remove: function( index ) {
			index = this._getIndex( index );
			var options = this.options,
				tab = this.tabs.eq( index ).remove(),
				panel = this._getPanelForTab( tab ).remove();

			// If selected tab was removed focus tab to the right or
			// in case the last tab was removed the tab to the left.
			// We check for more than 2 tabs, because if there are only 2,
			// then when we remove this tab, there will only be one tab left
			// so we don't need to detect which tab to activate.
			if ( tab.hasClass( "ui-tabs-active" ) && this.anchors.length > 2 ) {
				this._activate( index + ( index + 1 < this.anchors.length ? 1 : -1 ) );
			}

			options.disabled = $.map(
				$.grep( options.disabled, function( n ) {
					return n !== index;
				}),
				function( n ) {
					return n >= index ? --n : n;
				});

			this.refresh();

			this._trigger( "remove", null, this._ui( tab.find( "a" )[ 0 ], panel[ 0 ] ) );
			return this;
		}
	});

	// length method
	$.widget( "ui.tabs", $.ui.tabs, {
		length: function() {
			return this.anchors.length;
		}
	});

	// panel ids (idPrefix option + title attribute)
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			idPrefix: "ui-tabs-"
		},

		_tabId: function( tab ) {
			var a = tab.is( "li" ) ? tab.find( "a[href]" ) : tab;
			a = a[0];
			return $( a ).closest( "li" ).attr( "aria-controls" ) ||
				a.title && a.title.replace( /\s/g, "_" ).replace( /[^\w\u00c0-\uFFFF\-]/g, "" ) ||
				this.options.idPrefix + getNextTabId();
		}
	});

	// _createPanel method
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			panelTemplate: "<div></div>"
		},

		_createPanel: function( id ) {
			return $( this.options.panelTemplate )
				.attr( "id", id )
				.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
				.data( "ui-tabs-destroy", true );
		}
	});

	// selected option
	$.widget( "ui.tabs", $.ui.tabs, {
		_create: function() {
			var options = this.options;
			if ( options.active === null && options.selected !== undefined ) {
				options.active = options.selected === -1 ? false : options.selected;
			}
			this._super();
			options.selected = options.active;
			if ( options.selected === false ) {
				options.selected = -1;
			}
		},

		_setOption: function( key, value ) {
			if ( key !== "selected" ) {
				return this._super( key, value );
			}

			var options = this.options;
			this._super( "active", value === -1 ? false : value );
			options.selected = options.active;
			if ( options.selected === false ) {
				options.selected = -1;
			}
		},

		_eventHandler: function() {
			this._superApply( arguments );
			this.options.selected = this.options.active;
			if ( this.options.selected === false ) {
				this.options.selected = -1;
			}
		}
	});

	// show and select event
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			show: null,
			select: null
		},
		_create: function() {
			this._super();
			if ( this.options.active !== false ) {
				this._trigger( "show", null, this._ui(
					this.active.find( ".ui-tabs-anchor" )[ 0 ],
					this._getPanelForTab( this.active )[ 0 ] ) );
			}
		},
		_trigger: function( type, event, data ) {
			var tab, panel,
				ret = this._superApply( arguments );

			if ( !ret ) {
				return false;
			}

			if ( type === "beforeActivate" ) {
				tab = data.newTab.length ? data.newTab : data.oldTab;
				panel = data.newPanel.length ? data.newPanel : data.oldPanel;
				ret = this._super( "select", event, {
					tab: tab.find( ".ui-tabs-anchor" )[ 0],
					panel: panel[ 0 ],
					index: tab.closest( "li" ).index()
				});
			} else if ( type === "activate" && data.newTab.length ) {
				ret = this._super( "show", event, {
					tab: data.newTab.find( ".ui-tabs-anchor" )[ 0 ],
					panel: data.newPanel[ 0 ],
					index: data.newTab.closest( "li" ).index()
				});
			}
			return ret;
		}
	});

	// select method
	$.widget( "ui.tabs", $.ui.tabs, {
		select: function( index ) {
			index = this._getIndex( index );
			if ( index === -1 ) {
				if ( this.options.collapsible && this.options.selected !== -1 ) {
					index = this.options.selected;
				} else {
					return;
				}
			}
			this.anchors.eq( index ).trigger( this.options.event + this.eventNamespace );
		}
	});

	// cookie option
	(function() {

	var listId = 0;

	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			cookie: null // e.g. { expires: 7, path: '/', domain: 'jquery.com', secure: true }
		},
		_create: function() {
			var options = this.options,
				active;
			if ( options.active == null && options.cookie ) {
				active = parseInt( this._cookie(), 10 );
				if ( active === -1 ) {
					active = false;
				}
				options.active = active;
			}
			this._super();
		},
		_cookie: function( active ) {
			var cookie = [ this.cookie ||
				( this.cookie = this.options.cookie.name || "ui-tabs-" + (++listId) ) ];
			if ( arguments.length ) {
				cookie.push( active === false ? -1 : active );
				cookie.push( this.options.cookie );
			}
			return $.cookie.apply( null, cookie );
		},
		_refresh: function() {
			this._super();
			if ( this.options.cookie ) {
				this._cookie( this.options.active, this.options.cookie );
			}
		},
		_eventHandler: function() {
			this._superApply( arguments );
			if ( this.options.cookie ) {
				this._cookie( this.options.active, this.options.cookie );
			}
		},
		_destroy: function() {
			this._super();
			if ( this.options.cookie ) {
				this._cookie( null, this.options.cookie );
			}
		}
	});

	})();

	// load event
	$.widget( "ui.tabs", $.ui.tabs, {
		_trigger: function( type, event, data ) {
			var _data = $.extend( {}, data );
			if ( type === "load" ) {
				_data.panel = _data.panel[ 0 ];
				_data.tab = _data.tab.find( ".ui-tabs-anchor" )[ 0 ];
			}
			return this._super( type, event, _data );
		}
	});

	// fx option
	// The new animation options (show, hide) conflict with the old show callback.
	// The old fx option wins over show/hide anyway (always favor back-compat).
	// If a user wants to use the new animation API, they must give up the old API.
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			fx: null // e.g. { height: "toggle", opacity: "toggle", duration: 200 }
		},

		_getFx: function() {
			var hide, show,
				fx = this.options.fx;

			if ( fx ) {
				if ( $.isArray( fx ) ) {
					hide = fx[ 0 ];
					show = fx[ 1 ];
				} else {
					hide = show = fx;
				}
			}

			return fx ? { show: show, hide: hide } : null;
		},

		_toggle: function( event, eventData ) {
			var that = this,
				toShow = eventData.newPanel,
				toHide = eventData.oldPanel,
				fx = this._getFx();

			if ( !fx ) {
				return this._super( event, eventData );
			}

			that.running = true;

			function complete() {
				that.running = false;
				that._trigger( "activate", event, eventData );
			}

			function show() {
				eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

				if ( toShow.length && fx.show ) {
					toShow
						.animate( fx.show, fx.show.duration, function() {
							complete();
						});
				} else {
					toShow.show();
					complete();
				}
			}

			// start out by hiding, then showing, then completing
			if ( toHide.length && fx.hide ) {
				toHide.animate( fx.hide, fx.hide.duration, function() {
					eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
					show();
				});
			} else {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				toHide.hide();
				show();
			}
		}
	});
}

})( jQuery );

;/*!
 * jQuery UI Accordion 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/accordion/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var uid = 0,
	hideProps = {},
	showProps = {};

hideProps.height = hideProps.paddingTop = hideProps.paddingBottom =
	hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide";
showProps.height = showProps.paddingTop = showProps.paddingBottom =
	showProps.borderTopWidth = showProps.borderBottomWidth = "show";

$.widget( "ui.accordion", {
	version: "1.9.2",
	options: {
		active: 0,
		animate: {},
		collapsible: false,
		event: "click",
		header: "> li > :first-child,> :not(li):even",
		heightStyle: "auto",
		icons: {
			activeHeader: "ui-icon-triangle-1-s",
			header: "ui-icon-triangle-1-e"
		},

		// callbacks
		activate: null,
		beforeActivate: null
	},

	_create: function() {
		var accordionId = this.accordionId = "ui-accordion-" +
				(this.element.attr( "id" ) || ++uid),
			options = this.options;

		this.prevShow = this.prevHide = $();
		this.element.addClass( "ui-accordion ui-widget ui-helper-reset" );

		this.headers = this.element.find( options.header )
			.addClass( "ui-accordion-header ui-helper-reset ui-state-default ui-corner-all" );
		this._hoverable( this.headers );
		this._focusable( this.headers );

		this.headers.next()
			.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )
			.hide();

		// don't allow collapsible: false and active: false / null
		if ( !options.collapsible && (options.active === false || options.active == null) ) {
			options.active = 0;
		}
		// handle negative values
		if ( options.active < 0 ) {
			options.active += this.headers.length;
		}
		this.active = this._findActive( options.active )
			.addClass( "ui-accordion-header-active ui-state-active" )
			.toggleClass( "ui-corner-all ui-corner-top" );
		this.active.next()
			.addClass( "ui-accordion-content-active" )
			.show();

		this._createIcons();
		this.refresh();

		// ARIA
		this.element.attr( "role", "tablist" );

		this.headers
			.attr( "role", "tab" )
			.each(function( i ) {
				var header = $( this ),
					headerId = header.attr( "id" ),
					panel = header.next(),
					panelId = panel.attr( "id" );
				if ( !headerId ) {
					headerId = accordionId + "-header-" + i;
					header.attr( "id", headerId );
				}
				if ( !panelId ) {
					panelId = accordionId + "-panel-" + i;
					panel.attr( "id", panelId );
				}
				header.attr( "aria-controls", panelId );
				panel.attr( "aria-labelledby", headerId );
			})
			.next()
				.attr( "role", "tabpanel" );

		this.headers
			.not( this.active )
			.attr({
				"aria-selected": "false",
				tabIndex: -1
			})
			.next()
				.attr({
					"aria-expanded": "false",
					"aria-hidden": "true"
				})
				.hide();

		// make sure at least one header is in the tab order
		if ( !this.active.length ) {
			this.headers.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active.attr({
				"aria-selected": "true",
				tabIndex: 0
			})
			.next()
				.attr({
					"aria-expanded": "true",
					"aria-hidden": "false"
				});
		}

		this._on( this.headers, { keydown: "_keydown" });
		this._on( this.headers.next(), { keydown: "_panelKeyDown" });
		this._setupEvents( options.event );
	},

	_getCreateEventData: function() {
		return {
			header: this.active,
			content: !this.active.length ? $() : this.active.next()
		};
	},

	_createIcons: function() {
		var icons = this.options.icons;
		if ( icons ) {
			$( "<span>" )
				.addClass( "ui-accordion-header-icon ui-icon " + icons.header )
				.prependTo( this.headers );
			this.active.children( ".ui-accordion-header-icon" )
				.removeClass( icons.header )
				.addClass( icons.activeHeader );
			this.headers.addClass( "ui-accordion-icons" );
		}
	},

	_destroyIcons: function() {
		this.headers
			.removeClass( "ui-accordion-icons" )
			.children( ".ui-accordion-header-icon" )
				.remove();
	},

	_destroy: function() {
		var contents;

		// clean up main element
		this.element
			.removeClass( "ui-accordion ui-widget ui-helper-reset" )
			.removeAttr( "role" );

		// clean up headers
		this.headers
			.removeClass( "ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
			.removeAttr( "role" )
			.removeAttr( "aria-selected" )
			.removeAttr( "aria-controls" )
			.removeAttr( "tabIndex" )
			.each(function() {
				if ( /^ui-accordion/.test( this.id ) ) {
					this.removeAttribute( "id" );
				}
			});
		this._destroyIcons();

		// clean up content panels
		contents = this.headers.next()
			.css( "display", "" )
			.removeAttr( "role" )
			.removeAttr( "aria-expanded" )
			.removeAttr( "aria-hidden" )
			.removeAttr( "aria-labelledby" )
			.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled" )
			.each(function() {
				if ( /^ui-accordion/.test( this.id ) ) {
					this.removeAttribute( "id" );
				}
			});
		if ( this.options.heightStyle !== "content" ) {
			contents.css( "height", "" );
		}
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "event" ) {
			if ( this.options.event ) {
				this._off( this.headers, this.options.event );
			}
			this._setupEvents( value );
		}

		this._super( key, value );

		// setting collapsible: false while collapsed; open first panel
		if ( key === "collapsible" && !value && this.options.active === false ) {
			this._activate( 0 );
		}

		if ( key === "icons" ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}

		// #5332 - opacity doesn't cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		if ( key === "disabled" ) {
			this.headers.add( this.headers.next() )
				.toggleClass( "ui-state-disabled", !!value );
		}
	},

	_keydown: function( event ) {
		if ( event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
			case keyCode.RIGHT:
			case keyCode.DOWN:
				toFocus = this.headers[ ( currentIndex + 1 ) % length ];
				break;
			case keyCode.LEFT:
			case keyCode.UP:
				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
				break;
			case keyCode.SPACE:
			case keyCode.ENTER:
				this._eventHandler( event );
				break;
			case keyCode.HOME:
				toFocus = this.headers[ 0 ];
				break;
			case keyCode.END:
				toFocus = this.headers[ length - 1 ];
				break;
		}

		if ( toFocus ) {
			$( event.target ).attr( "tabIndex", -1 );
			$( toFocus ).attr( "tabIndex", 0 );
			toFocus.focus();
			event.preventDefault();
		}
	},

	_panelKeyDown : function( event ) {
		if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
			$( event.currentTarget ).prev().focus();
		}
	},

	refresh: function() {
		var maxHeight, overflow,
			heightStyle = this.options.heightStyle,
			parent = this.element.parent();


		if ( heightStyle === "fill" ) {
			// IE 6 treats height like minHeight, so we need to turn off overflow
			// in order to get a reliable height
			// we use the minHeight support test because we assume that only
			// browsers that don't support minHeight will treat height as minHeight
			if ( !$.support.minHeight ) {
				overflow = parent.css( "overflow" );
				parent.css( "overflow", "hidden");
			}
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});
			if ( overflow ) {
				parent.css( "overflow", overflow );
			}

			this.headers.each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.headers.next()
				.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.headers.next()
				.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
				})
				.height( maxHeight );
		}
	},

	_activate: function( index ) {
		var active = this._findActive( index )[ 0 ];

		// trying to activate the already active panel
		if ( active === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the currently active header
		active = active || this.active[ 0 ];

		this._eventHandler({
			target: active,
			currentTarget: active,
			preventDefault: $.noop
		});
	},

	_findActive: function( selector ) {
		return typeof selector === "number" ? this.headers.eq( selector ) : $();
	},

	_setupEvents: function( event ) {
		var events = {};
		if ( !event ) {
			return;
		}
		$.each( event.split(" "), function( index, eventName ) {
			events[ eventName ] = "_eventHandler";
		});
		this._on( this.headers, events );
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			clicked = $( event.currentTarget ),
			clickedIsActive = clicked[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : clicked.next(),
			toHide = active.next(),
			eventData = {
				oldHeader: active,
				oldPanel: toHide,
				newHeader: collapsing ? $() : clicked,
				newPanel: toShow
			};

		event.preventDefault();

		if (
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.headers.index( clicked );

		// when the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $() : clicked;
		this._toggle( eventData );

		// switch classes
		// corner classes on the previously active header stay after the animation
		active.removeClass( "ui-accordion-header-active ui-state-active" );
		if ( options.icons ) {
			active.children( ".ui-accordion-header-icon" )
				.removeClass( options.icons.activeHeader )
				.addClass( options.icons.header );
		}

		if ( !clickedIsActive ) {
			clicked
				.removeClass( "ui-corner-all" )
				.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );
			if ( options.icons ) {
				clicked.children( ".ui-accordion-header-icon" )
					.removeClass( options.icons.header )
					.addClass( options.icons.activeHeader );
			}

			clicked
				.next()
				.addClass( "ui-accordion-content-active" );
		}
	},

	_toggle: function( data ) {
		var toShow = data.newPanel,
			toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

		// handle activating a panel during the animation for another activation
		this.prevShow.add( this.prevHide ).stop( true, true );
		this.prevShow = toShow;
		this.prevHide = toHide;

		if ( this.options.animate ) {
			this._animate( toShow, toHide, data );
		} else {
			toHide.hide();
			toShow.show();
			this._toggleComplete( data );
		}

		toHide.attr({
			"aria-expanded": "false",
			"aria-hidden": "true"
		});
		toHide.prev().attr( "aria-selected", "false" );
		// if we're switching panels, remove the old header from the tab order
		// if we're opening from collapsed state, remove the previous header from the tab order
		// if we're collapsing, then keep the collapsing header in the tab order
		if ( toShow.length && toHide.length ) {
			toHide.prev().attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.headers.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow
			.attr({
				"aria-expanded": "true",
				"aria-hidden": "false"
			})
			.prev()
				.attr({
					"aria-selected": "true",
					tabIndex: 0
				});
	},

	_animate: function( toShow, toHide, data ) {
		var total, easing, duration,
			that = this,
			adjust = 0,
			down = toShow.length &&
				( !toHide.length || ( toShow.index() < toHide.index() ) ),
			animate = this.options.animate || {},
			options = down && animate.down || animate,
			complete = function() {
				that._toggleComplete( data );
			};

		if ( typeof options === "number" ) {
			duration = options;
		}
		if ( typeof options === "string" ) {
			easing = options;
		}
		// fall back from options to animation in case of partial down settings
		easing = easing || options.easing || animate.easing;
		duration = duration || options.duration || animate.duration;

		if ( !toHide.length ) {
			return toShow.animate( showProps, duration, easing, complete );
		}
		if ( !toShow.length ) {
			return toHide.animate( hideProps, duration, easing, complete );
		}

		total = toShow.show().outerHeight();
		toHide.animate( hideProps, {
			duration: duration,
			easing: easing,
			step: function( now, fx ) {
				fx.now = Math.round( now );
			}
		});
		toShow
			.hide()
			.animate( showProps, {
				duration: duration,
				easing: easing,
				complete: complete,
				step: function( now, fx ) {
					fx.now = Math.round( now );
					if ( fx.prop !== "height" ) {
						adjust += fx.now;
					} else if ( that.options.heightStyle !== "content" ) {
						fx.now = Math.round( total - toHide.outerHeight() - adjust );
						adjust = 0;
					}
				}
			});
	},

	_toggleComplete: function( data ) {
		var toHide = data.oldPanel;

		toHide
			.removeClass( "ui-accordion-content-active" )
			.prev()
				.removeClass( "ui-corner-top" )
				.addClass( "ui-corner-all" );

		// Work around for rendering bug in IE (#5421)
		if ( toHide.length ) {
			toHide.parent()[0].className = toHide.parent()[0].className;
		}

		this._trigger( "activate", null, data );
	}
});



// DEPRECATED
if ( $.uiBackCompat !== false ) {
	// navigation options
	(function( $, prototype ) {
		$.extend( prototype.options, {
			navigation: false,
			navigationFilter: function() {
				return this.href.toLowerCase() === location.href.toLowerCase();
			}
		});

		var _create = prototype._create;
		prototype._create = function() {
			if ( this.options.navigation ) {
				var that = this,
					headers = this.element.find( this.options.header ),
					content = headers.next(),
					current = headers.add( content )
						.find( "a" )
						.filter( this.options.navigationFilter )
						[ 0 ];
				if ( current ) {
					headers.add( content ).each( function( index ) {
						if ( $.contains( this, current ) ) {
							that.options.active = Math.floor( index / 2 );
							return false;
						}
					});
				}
			}
			_create.call( this );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// height options
	(function( $, prototype ) {
		$.extend( prototype.options, {
			heightStyle: null, // remove default so we fall back to old values
			autoHeight: true, // use heightStyle: "auto"
			clearStyle: false, // use heightStyle: "content"
			fillSpace: false // use heightStyle: "fill"
		});

		var _create = prototype._create,
			_setOption = prototype._setOption;

		$.extend( prototype, {
			_create: function() {
				this.options.heightStyle = this.options.heightStyle ||
					this._mergeHeightStyle();

				_create.call( this );
			},

			_setOption: function( key ) {
				if ( key === "autoHeight" || key === "clearStyle" || key === "fillSpace" ) {
					this.options.heightStyle = this._mergeHeightStyle();
				}
				_setOption.apply( this, arguments );
			},

			_mergeHeightStyle: function() {
				var options = this.options;

				if ( options.fillSpace ) {
					return "fill";
				}

				if ( options.clearStyle ) {
					return "content";
				}

				if ( options.autoHeight ) {
					return "auto";
				}
			}
		});
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// icon options
	(function( $, prototype ) {
		$.extend( prototype.options.icons, {
			activeHeader: null, // remove default so we fall back to old values
			headerSelected: "ui-icon-triangle-1-s"
		});

		var _createIcons = prototype._createIcons;
		prototype._createIcons = function() {
			if ( this.options.icons ) {
				this.options.icons.activeHeader = this.options.icons.activeHeader ||
					this.options.icons.headerSelected;
			}
			_createIcons.call( this );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// expanded active option, activate method
	(function( $, prototype ) {
		prototype.activate = prototype._activate;

		var _findActive = prototype._findActive;
		prototype._findActive = function( index ) {
			if ( index === -1 ) {
				index = false;
			}
			if ( index && typeof index !== "number" ) {
				index = this.headers.index( this.headers.filter( index ) );
				if ( index === -1 ) {
					index = false;
				}
			}
			return _findActive.call( this, index );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// resize method
	jQuery.ui.accordion.prototype.resize = jQuery.ui.accordion.prototype.refresh;

	// change events
	(function( $, prototype ) {
		$.extend( prototype.options, {
			change: null,
			changestart: null
		});

		var _trigger = prototype._trigger;
		prototype._trigger = function( type, event, data ) {
			var ret = _trigger.apply( this, arguments );
			if ( !ret ) {
				return false;
			}

			if ( type === "beforeActivate" ) {
				ret = _trigger.call( this, "changestart", event, {
					oldHeader: data.oldHeader,
					oldContent: data.oldPanel,
					newHeader: data.newHeader,
					newContent: data.newPanel
				});
			} else if ( type === "activate" ) {
				ret = _trigger.call( this, "change", event, {
					oldHeader: data.oldHeader,
					oldContent: data.oldPanel,
					newHeader: data.newHeader,
					newContent: data.newPanel
				});
			}
			return ret;
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// animated option
	// NOTE: this only provides support for "slide", "bounceslide", and easings
	// not the full $.ui.accordion.animations API
	(function( $, prototype ) {
		$.extend( prototype.options, {
			animate: null,
			animated: "slide"
		});

		var _create = prototype._create;
		prototype._create = function() {
			var options = this.options;
			if ( options.animate === null ) {
				if ( !options.animated ) {
					options.animate = false;
				} else if ( options.animated === "slide" ) {
					options.animate = 300;
				} else if ( options.animated === "bounceslide" ) {
					options.animate = {
						duration: 200,
						down: {
							easing: "easeOutBounce",
							duration: 1000
						}
					};
				} else {
					options.animate = options.animated;
				}
			}

			_create.call( this );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );
}

})( jQuery );

;/*!
 * jQuery UI Mouse 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function( e ) {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	version: "1.9.2",
	options: {
		cancel: 'input,textarea,button,select,option',
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind('mousedown.'+this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind('click.'+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + '.preventClickEvent')) {
					$.removeData(event.target, that.widgetName + '.preventClickEvent');
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind('.'+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
				.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
			$.removeData(event.target, this.widgetName + '.preventClickEvent');
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.bind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie && !(document.documentMode >= 9) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + '.preventClickEvent', true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(event) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(event) {},
	_mouseDrag: function(event) {},
	_mouseStop: function(event) {},
	_mouseCapture: function(event) { return true; }
});

})(jQuery);

;/*!
 * jQuery UI Button 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/button/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var lastActive, startXPos, startYPos, clickDragged,
	baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
	stateClasses = "ui-state-hover ui-state-active ",
	typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
	formResetHandler = function() {
		var buttons = $( this ).find( ":ui-button" );
		setTimeout(function() {
			buttons.button( "refresh" );
		}, 1 );
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			if ( form ) {
				radios = $( form ).find( "[name='" + name + "']" );
			} else {
				radios = $( "[name='" + name + "']", radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( "ui.button", {
	version: "1.9.2",
	defaultElement: "<button>",
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( "form" )
			.unbind( "reset" + this.eventNamespace )
			.bind( "reset" + this.eventNamespace, formResetHandler );

		if ( typeof this.options.disabled !== "boolean" ) {
			this.options.disabled = !!this.element.prop( "disabled" );
		} else {
			this.element.prop( "disabled", this.options.disabled );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( "title" );

		var that = this,
			options = this.options,
			toggleButton = this.type === "checkbox" || this.type === "radio",
			activeClass = !toggleButton ? "ui-state-active" : "",
			focusClass = "ui-state-focus";

		if ( options.label === null ) {
			options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
		}

		this._hoverable( this.buttonElement );

		this.buttonElement
			.addClass( baseClasses )
			.attr( "role", "button" )
			.bind( "mouseenter" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				if ( this === lastActive ) {
					$( this ).addClass( "ui-state-active" );
				}
			})
			.bind( "mouseleave" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( activeClass );
			})
			.bind( "click" + this.eventNamespace, function( event ) {
				if ( options.disabled ) {
					event.preventDefault();
					event.stopImmediatePropagation();
				}
			});

		this.element
			.bind( "focus" + this.eventNamespace, function() {
				// no need to check disabled, focus won't be triggered anyway
				that.buttonElement.addClass( focusClass );
			})
			.bind( "blur" + this.eventNamespace, function() {
				that.buttonElement.removeClass( focusClass );
			});

		if ( toggleButton ) {
			this.element.bind( "change" + this.eventNamespace, function() {
				if ( clickDragged ) {
					return;
				}
				that.refresh();
			});
			// if mouse moves between mousedown and mouseup (drag) set clickDragged flag
			// prevents issue where button state changes but checkbox/radio checked state
			// does not in Firefox (see ticket #6970)
			this.buttonElement
				.bind( "mousedown" + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						return;
					}
					clickDragged = false;
					startXPos = event.pageX;
					startYPos = event.pageY;
				})
				.bind( "mouseup" + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						return;
					}
					if ( startXPos !== event.pageX || startYPos !== event.pageY ) {
						clickDragged = true;
					}
			});
		}

		if ( this.type === "checkbox" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).toggleClass( "ui-state-active" );
				that.buttonElement.attr( "aria-pressed", that.element[0].checked );
			});
		} else if ( this.type === "radio" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).addClass( "ui-state-active" );
				that.buttonElement.attr( "aria-pressed", "true" );

				var radio = that.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( "widget" )[ 0 ];
					})
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			});
		} else {
			this.buttonElement
				.bind( "mousedown" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( "ui-state-active" );
					lastActive = this;
					that.document.one( "mouseup", function() {
						lastActive = null;
					});
				})
				.bind( "mouseup" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( "ui-state-active" );
				})
				.bind( "keydown" + this.eventNamespace, function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
						$( this ).addClass( "ui-state-active" );
					}
				})
				.bind( "keyup" + this.eventNamespace, function() {
					$( this ).removeClass( "ui-state-active" );
				});

			if ( this.buttonElement.is("a") ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						// TODO pass through original event correctly (just as 2nd argument doesn't work)
						$( this ).click();
					}
				});
			}
		}

		// TODO: pull out $.Widget's handling for the disabled option into
		// $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
		// be overridden by individual plugins
		this._setOption( "disabled", options.disabled );
		this._resetButton();
	},

	_determineButtonType: function() {
		var ancestor, labelSelector, checked;

		if ( this.element.is("[type=checkbox]") ) {
			this.type = "checkbox";
		} else if ( this.element.is("[type=radio]") ) {
			this.type = "radio";
		} else if ( this.element.is("input") ) {
			this.type = "input";
		} else {
			this.type = "button";
		}

		if ( this.type === "checkbox" || this.type === "radio" ) {
			// we don't search against the document in case the element
			// is disconnected from the DOM
			ancestor = this.element.parents().last();
			labelSelector = "label[for='" + this.element.attr("id") + "']";
			this.buttonElement = ancestor.find( labelSelector );
			if ( !this.buttonElement.length ) {
				ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
				this.buttonElement = ancestor.filter( labelSelector );
				if ( !this.buttonElement.length ) {
					this.buttonElement = ancestor.find( labelSelector );
				}
			}
			this.element.addClass( "ui-helper-hidden-accessible" );

			checked = this.element.is( ":checked" );
			if ( checked ) {
				this.buttonElement.addClass( "ui-state-active" );
			}
			this.buttonElement.prop( "aria-pressed", checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-helper-hidden-accessible" );
		this.buttonElement
			.removeClass( baseClasses + " " + stateClasses + " " + typeClasses )
			.removeAttr( "role" )
			.removeAttr( "aria-pressed" )
			.html( this.buttonElement.find(".ui-button-text").html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( "title" );
		}
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "disabled" ) {
			if ( value ) {
				this.element.prop( "disabled", true );
			} else {
				this.element.prop( "disabled", false );
			}
			return;
		}
		this._resetButton();
	},

	refresh: function() {
		//See #8237 & #8828
		var isDisabled = this.element.is( "input, button" ) ? this.element.is( ":disabled" ) : this.element.hasClass( "ui-button-disabled" );

		if ( isDisabled !== this.options.disabled ) {
			this._setOption( "disabled", isDisabled );
		}
		if ( this.type === "radio" ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( ":checked" ) ) {
					$( this ).button( "widget" )
						.addClass( "ui-state-active" )
						.attr( "aria-pressed", "true" );
				} else {
					$( this ).button( "widget" )
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				}
			});
		} else if ( this.type === "checkbox" ) {
			if ( this.element.is( ":checked" ) ) {
				this.buttonElement
					.addClass( "ui-state-active" )
					.attr( "aria-pressed", "true" );
			} else {
				this.buttonElement
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === "input" ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( "<span></span>", this.document[0] )
				.addClass( "ui-button-text" )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary && icons.secondary,
			buttonClasses = [];

		if ( icons.primary || icons.secondary ) {
			if ( this.options.text ) {
				buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
			}

			if ( icons.primary ) {
				buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
			}

			if ( icons.secondary ) {
				buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
			}

			if ( !this.options.text ) {
				buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );

				if ( !this.hasTitle ) {
					buttonElement.attr( "title", $.trim( buttonText ) );
				}
			}
		} else {
			buttonClasses.push( "ui-button-text-only" );
		}
		buttonElement.addClass( buttonClasses.join( " " ) );
	}
});

$.widget( "ui.buttonset", {
	version: "1.9.2",
	options: {
		items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(button)"
	},

	_create: function() {
		this.element.addClass( "ui-buttonset" );
	},

	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === "disabled" ) {
			this.buttons.button( "option", key, value );
		}

		this._super( key, value );
	},

	refresh: function() {
		var rtl = this.element.css( "direction" ) === "rtl";

		this.buttons = this.element.find( this.options.items )
			.filter( ":ui-button" )
				.button( "refresh" )
			.end()
			.not( ":ui-button" )
				.button()
			.end()
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
				.filter( ":first" )
					.addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
				.end()
				.filter( ":last" )
					.addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
				.end()
			.end();
	},

	_destroy: function() {
		this.element.removeClass( "ui-buttonset" );
		this.buttons
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-left ui-corner-right" )
			.end()
			.button( "destroy" );
	}
});

}( jQuery ) );

;/*!
 * jQuery UI Slider 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/slider/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {
	version: "1.9.2",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null
	},

	_create: function() {
		var i, handleCount,
			o = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
			handles = [];

		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" +
				( o.disabled ? " ui-slider-disabled ui-disabled" : "" ) );

		this.range = $([]);

		if ( o.range ) {
			if ( o.range === true ) {
				if ( !o.values ) {
					o.values = [ this._valueMin(), this._valueMin() ];
				}
				if ( o.values.length && o.values.length !== 2 ) {
					o.values = [ o.values[0], o.values[0] ];
				}
			}

			this.range = $( "<div></div>" )
				.appendTo( this.element )
				.addClass( "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header" +
				( ( o.range === "min" || o.range === "max" ) ? " ui-slider-range-" + o.range : "" ) );
		}

		handleCount = ( o.values && o.values.length ) || 1;

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.add( this.range ).filter( "a" )
			.click(function( event ) {
				event.preventDefault();
			})
			.mouseenter(function() {
				if ( !o.disabled ) {
					$( this ).addClass( "ui-state-hover" );
				}
			})
			.mouseleave(function() {
				$( this ).removeClass( "ui-state-hover" );
			})
			.focus(function() {
				if ( !o.disabled ) {
					$( ".ui-slider .ui-state-focus" ).removeClass( "ui-state-focus" );
					$( this ).addClass( "ui-state-focus" );
				} else {
					$( this ).blur();
				}
			})
			.blur(function() {
				$( this ).removeClass( "ui-state-focus" );
			});

		this.handles.each(function( i ) {
			$( this ).data( "ui-slider-handle-index", i );
		});

		this._on( this.handles, {
			keydown: function( event ) {
				var allowed, curVal, newVal, step,
					index = $( event.target ).data( "ui-slider-handle-index" );

				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						event.preventDefault();
						if ( !this._keySliding ) {
							this._keySliding = true;
							$( event.target ).addClass( "ui-state-active" );
							allowed = this._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}

				step = this.options.step;
				if ( this.options.values && this.options.values.length ) {
					curVal = newVal = this.values( index );
				} else {
					curVal = newVal = this.value();
				}

				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = this._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = this._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === this._valueMax() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === this._valueMin() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal - step );
						break;
				}

				this._slide( event, index, newVal );
			},
			keyup: function( event ) {
				var index = $( event.target ).data( "ui-slider-handle-index" );

				if ( this._keySliding ) {
					this._keySliding = false;
					this._stop( event, index );
					this._change( event, index );
					$( event.target ).removeClass( "ui-state-active" );
				}
			}
		});

		this._refreshValue();

		this._animateOff = false;
	},

	_destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-slider-disabled" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" );

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - that.values(i) );
			if ( distance > thisDistance ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		// workaround for bug #3736 (if both handles of a range are at 0,
		// the first is always used as the one with least distance,
		// and moving it is obviously prevented by preventing negative ranges)
		if( o.range === true && this.values(1) === o.min ) {
			index += 1;
			closestHandle = $( this.handles[index] );
		}

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().andSelf().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) &&
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case "disabled":
				if ( value ) {
					this.handles.filter( ".ui-state-focus" ).blur();
					this.handles.removeClass( "ui-state-hover" );
					this.handles.prop( "disabled", true );
					this.element.addClass( "ui-disabled" );
				} else {
					this.handles.prop( "disabled", false );
					this.element.removeClass( "ui-disabled" );
				}
				break;
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case "min":
			case "max":
				this._animateOff = true;
				this._refreshValue();
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		}
	},

	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i ) {
				valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	}

});

}(jQuery));

;/*!
 * hoverIntent r7 // 2013.03.11 // jQuery 1.9.1+
 * http://cherne.net/brian/resources/jquery.hoverIntent.html
 *
 * You may use hoverIntent under the terms of the MIT license.
 * Copyright 2007, 2013 Brian Cherne
 */
(function(e){e.fn.hoverIntent=function(t,n,r){var i={interval:100,sensitivity:7,timeout:0};if(typeof t==="object"){i=e.extend(i,t)}else if(e.isFunction(n)){i=e.extend(i,{over:t,out:n,selector:r})}else{i=e.extend(i,{over:t,out:t,selector:n})}var s,o,u,a;var f=function(e){s=e.pageX;o=e.pageY};var l=function(t,n){n.hoverIntent_t=clearTimeout(n.hoverIntent_t);if(Math.abs(u-s)+Math.abs(a-o)<i.sensitivity){e(n).off("mousemove.hoverIntent",f);n.hoverIntent_s=1;return i.over.apply(n,[t])}else{u=s;a=o;n.hoverIntent_t=setTimeout(function(){l(t,n)},i.interval)}};var c=function(e,t){t.hoverIntent_t=clearTimeout(t.hoverIntent_t);t.hoverIntent_s=0;return i.out.apply(t,[e])};var h=function(t){var n=jQuery.extend({},t);var r=this;if(r.hoverIntent_t){r.hoverIntent_t=clearTimeout(r.hoverIntent_t)}if(t.type=="mouseenter"){u=n.pageX;a=n.pageY;e(r).on("mousemove.hoverIntent",f);if(r.hoverIntent_s!=1){r.hoverIntent_t=setTimeout(function(){l(n,r)},i.interval)}}else{e(r).off("mousemove.hoverIntent",f);if(r.hoverIntent_s==1){r.hoverIntent_t=setTimeout(function(){c(n,r)},i.timeout)}}};return this.on({"mouseenter.hoverIntent":h,"mouseleave.hoverIntent":h},i.selector)}})(jQuery)
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, newcap: true */

(function ($, win) {

  'use strict';

  //Declare namespaces
  win.Deltatre = win.Deltatre || {};
  win.Deltatre.plugins = win.Deltatre.plugins || {};

  //shortcuts
  var d3 = win.Deltatre;
  //var trace = d3.Trace;


  var defaults = {
    islegacy: true,
    immediate: false,
    timestamp: '',                        //marcatore utilizzato per il confronto di versione
    timeout: 0,                           //timeout di refresh in millisecondi 
    urlcheck: '',                         //path alla library che restituisce il timestamp aggiornato
    urlget: '',                           //path alla library con il contenuto aggiornato 
    timerid: 0,                           //identificativo del timer
    elapsed: new Date(),                  //identificativo del timer
    callbackCheck: false,                 //function (data) { } callback dopo aver effettuato il check
    callback: function (html, $dom) {     //callback dopo aver effettuato l'aggiornamento
      win.Deltatre.core.getInstance().parse($(html));
      $dom.html(html);
    }
  };

  /**
  * uefaLive 2.0.0. Server push simulator
  * 
  * Launch  : October 2013
  * Version : 1.0.0
  * Released: Massimiliano Balestrieri
  *
  */
  var uefaLive = function (e, opt) {

    /* ------------------------- */
    /* Variables */
    //var _this = this;
    var $dom = e; //the jquery element we are working with

    var _initial,
        _data = opt,
        _debug = (/isdebug/i).test(document.location.href);

    /* ------------------------- */
    /* Declaring private functions */
    var _poll, _refresh, _checkVersion, _exists, _elapsed, _children;

    /* ------------------------- */
    //Public Functions

    this.init = function () {

      $dom.addClass('js-uefa-live');

      _initial = _data.timeout;

      _poll(true);

    };

    this.destroy = function (empty) {
      win.clearTimeout(_data.timerid);
      if (empty) {

        $dom
        .empty(true);
        //.remove(true);

      }
    };

    this.stop = function () {
      win.clearTimeout(_data.timerid);
    };


    /* ------------------------- */
    //Private Functions
    _poll = function (start) {
      if (_exists() && _data.timeout > 0) {
        //trace(_data);
        if (_data.urlcheck) {
          _data.timerid = win.setTimeout(function () {
            _checkVersion();
          }, _data.timeout);
        } else {
          if (opt.immediate && start) {
            _refresh();
          } else {
            _data.timerid = win.setTimeout(function () {
              _refresh();
            }, _data.timeout);
          }
        }
      }
    };

    _checkVersion = function () {

      win.clearTimeout(_data.timerid);

      $.ajax({
        type: "GET",
        cache: false,
        url: _data.urlcheck,
        dataType: 'json',
        error: function () {
          d3.Trace("Error json - Live stopped - ", $dom);
        },
        success: function (data) {


          if (_debug) {

            _elapsed();

            data.timeout = _initial;

          }


          if (_data.timestamp.toString() !== data.timestamp.toString()) {

            $.extend(_data, data);

            //trace('uefalive - refresh - ', $dom);

            _refresh();

          } else {

            $.extend(_data, data);

            //Element is not detached
            if (_data.timeout > 0 && _exists()) {
              _data.timerid = win.setTimeout(function () {
                _checkVersion();
              }, _data.timeout);
            }

          }

          if (opt.callbackCheck && $.isFunction(opt.callbackCheck)) {
            opt.callbackCheck(data);
          }

        }
      });
    };

    _refresh = function () {
      if (_data.urlcheck) {
        win.clearTimeout(_data.timerid);
      }

      //trace(_data.urlget);
      if (_data.urlget !== '') {
        $.ajax({
          type: "GET",
          cache: false,
          url: _data.urlget,
          success: function (html) {

            if (_debug && !_data.urlcheck) {
              _elapsed();
            }

            _children();

            if (opt.islegacy) {
              opt.callback($dom, html);
            } else {
              opt.callback(html, $dom);
            }


            _poll(false);

          }
        });

      }

    };

    _exists = function () {
      var _ret = $.contains ? $.contains(document.documentElement, $dom[0]) : $dom.closest('html').length > 0;
      //d3.Trace($dom.closest('html'));
      //d3.Trace(_ret)
      return _ret;
    };

    _elapsed = function () {
      var now = +(new Date());
      //trace(_exists(), $dom, Math.round((now - _data.elapsed) / 1000), _data.timeout, (new Date()));
      _data.elapsed = now;
    };

    _children = function () {
      if (opt.empty) {

        //trace('destroy - ', $dom.find('.js-uefa-live'));

        $dom.find('.js-uefa-live').each(function () {

          var _api = $(this).data('uefaLive');

          //trace('destroy - api - ', _api);

          if (_api) {
            _api.destroy(true);
          }

        });

      }
    };
  };

  $.fn.uefaLive = function (opt) {

    if (opt.islegacy !== false) {
      defaults.callback = undefined;
    }

    var _opt = $.extend(true, {}, defaults, opt || {});  //options	

    return this.each(function () {

      var api = new uefaLive($(this), _opt);
      api.init();

      $(this).data("uefaLive", api);

    });

  };


} (jQuery, window));
;/*!
 * jCarousel - Riding carousels with jQuery
 *   http://sorgalla.com/jcarousel/
 *
 * Copyright (c) 2006 Jan Sorgalla (http://sorgalla.com)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 *
 * Built on top of the jQuery library
 *   http://jquery.com
 *
 * Inspired by the "Carousel Component" by Bill Scott
 *   http://billwscott.com/carousel/
 */

/*global window, jQuery */
(function($) {
    // Default configuration properties.
    var defaults = {
        vertical: false,
        rtl: false,
        start: 1,
        offset: 1,
        size: null,
        scroll: 3,
        visible: null,
        animation: 'normal',
        easing: 'swing',
        auto: 0,
        wrap: null,
        initCallback: null,
        setupCallback: null,
        reloadCallback: null,
        itemLoadCallback: null,
        itemFirstInCallback: null,
        itemFirstOutCallback: null,
        itemLastInCallback: null,
        itemLastOutCallback: null,
        itemVisibleInCallback: null,
        itemVisibleOutCallback: null,
        animationStepCallback: null,
        buttonNextHTML: '<div></div>',
        buttonPrevHTML: '<div></div>',
        buttonNextEvent: 'click',
        buttonPrevEvent: 'click',
        buttonNextCallback: null,
        buttonPrevCallback: null,
        itemFallbackDimension: null
    }, windowLoaded = false;

    $(window).bind('load.jcarousel', function() { windowLoaded = true; });

    /**
     * The jCarousel object.
     *
     * @constructor
     * @class jcarousel
     * @param e {HTMLElement} The element to create the carousel for.
     * @param o {Object} A set of key/value pairs to set as configuration properties.
     * @cat Plugins/jCarousel
     */
    $.jcarousel = function(e, o) {
        this.options    = $.extend({}, defaults, o || {});

        this.locked          = false;
        this.autoStopped     = false;

        this.container       = null;
        this.clip            = null;
        this.list            = null;
        this.buttonNext      = null;
        this.buttonPrev      = null;
        this.buttonNextState = null;
        this.buttonPrevState = null;

        // Only set if not explicitly passed as option
        if (!o || o.rtl === undefined) {
            this.options.rtl = ($(e).attr('dir') || $('html').attr('dir') || '').toLowerCase() == 'rtl';
        }

        this.wh = !this.options.vertical ? 'width' : 'height';
        this.lt = !this.options.vertical ? (this.options.rtl ? 'right' : 'left') : 'top';

        // Extract skin class
        var skin = '', split = e.className.split(' ');

        for (var i = 0; i < split.length; i++) {
            if (split[i].indexOf('jcarousel-skin') != -1) {
                $(e).removeClass(split[i]);
                skin = split[i];
                break;
            }
        }

        if (e.nodeName.toUpperCase() == 'UL' || e.nodeName.toUpperCase() == 'OL') {
            this.list      = $(e);
            this.clip      = this.list.parents('.jcarousel-clip');
            this.container = this.list.parents('.jcarousel-container');
        } else {
            this.container = $(e);
            this.list      = this.container.find('ul,ol').eq(0);
            this.clip      = this.container.find('.jcarousel-clip');
        }

        if (this.clip.size() === 0) {
            this.clip = this.list.wrap('<div></div>').parent();
        }

        if (this.container.size() === 0) {
            this.container = this.clip.wrap('<div></div>').parent();
        }

        if (skin !== '' && this.container.parent()[0].className.indexOf('jcarousel-skin') == -1) {
            this.container.wrap('<div class=" '+ skin + '"></div>');
        }

        this.buttonPrev = $('.jcarousel-prev', this.container);

        if (this.buttonPrev.size() === 0 && this.options.buttonPrevHTML !== null) {
            this.buttonPrev = $(this.options.buttonPrevHTML).appendTo(this.container);
        }

        this.buttonPrev.addClass(this.className('jcarousel-prev'));

        this.buttonNext = $('.jcarousel-next', this.container);

        if (this.buttonNext.size() === 0 && this.options.buttonNextHTML !== null) {
            this.buttonNext = $(this.options.buttonNextHTML).appendTo(this.container);
        }

        this.buttonNext.addClass(this.className('jcarousel-next'));

        this.clip.addClass(this.className('jcarousel-clip')).css({
            position: 'relative'
        });

        this.list.addClass(this.className('jcarousel-list')).css({
            overflow: 'hidden',
            position: 'relative',
            top: 0,
            margin: 0,
            padding: 0
        }).css((this.options.rtl ? 'right' : 'left'), 0);

        this.container.addClass(this.className('jcarousel-container')).css({
            position: 'relative'
        });

        if (!this.options.vertical && this.options.rtl) {
            this.container.addClass('jcarousel-direction-rtl').attr('dir', 'rtl');
        }

        var di = this.options.visible !== null ? Math.ceil(this.clipping() / this.options.visible) : null;
        var li = this.list.children('li');

        var self = this;

        if (li.size() > 0) {
            var wh = 0, j = this.options.offset;
            li.each(function() {
                self.format(this, j++);
                wh += self.dimension(this, di);
            });

            this.list.css(this.wh, (wh + 100) + 'px');

            // Only set if not explicitly passed as option
            if (!o || o.size === undefined) {
                this.options.size = li.size();
            }
        }

        // For whatever reason, .show() does not work in Safari...
        this.container.css('display', 'block');
        this.buttonNext.css('display', 'block');
        this.buttonPrev.css('display', 'block');

        this.funcNext   = function() { self.next(); return false; };
        this.funcPrev   = function() { self.prev(); return false; };
        this.funcResize = function() {
            if (self.resizeTimer) {
                clearTimeout(self.resizeTimer);
            }

            self.resizeTimer = setTimeout(function() {
                self.reload();
            }, 100);
        };

        if (this.options.initCallback !== null) {
            this.options.initCallback(this, 'init');
        }

        if (!windowLoaded && $jc.isSafari()) {
            this.buttons(false, false);
            $(window).bind('load.jcarousel', function() { self.setup(); });
        } else {
            this.setup();
        }
    };

    // Create shortcut for internal use
    var $jc = $.jcarousel;

    $jc.fn = $jc.prototype = {
        jcarousel: '0.2.9'
    };

    $jc.fn.extend = $jc.extend = $.extend;

    $jc.fn.extend({
        /**
         * Setups the carousel.
         *
         * @method setup
         * @return undefined
         */
        setup: function() {
            this.first       = null;
            this.last        = null;
            this.prevFirst   = null;
            this.prevLast    = null;
            this.animating   = false;
            this.timer       = null;
            this.resizeTimer = null;
            this.tail        = null;
            this.inTail      = false;

            if (this.locked) {
                return;
            }

            this.list.css(this.lt, this.pos(this.options.offset) + 'px');
            var p = this.pos(this.options.start, true);
            this.prevFirst = this.prevLast = null;
            this.animate(p, false);

            $(window).unbind('resize.jcarousel', this.funcResize).bind('resize.jcarousel', this.funcResize);

            if (this.options.setupCallback !== null) {
                this.options.setupCallback(this);
            }
        },

        /**
         * Clears the list and resets the carousel.
         *
         * @method reset
         * @return undefined
         */
        reset: function() {
            this.list.empty();

            this.list.css(this.lt, '0px');
            this.list.css(this.wh, '10px');

            if (this.options.initCallback !== null) {
                this.options.initCallback(this, 'reset');
            }

            this.setup();
        },

        /**
         * Reloads the carousel and adjusts positions.
         *
         * @method reload
         * @return undefined
         */
        reload: function() {
            if (this.tail !== null && this.inTail) {
                this.list.css(this.lt, $jc.intval(this.list.css(this.lt)) + this.tail);
            }

            this.tail   = null;
            this.inTail = false;

            if (this.options.reloadCallback !== null) {
                this.options.reloadCallback(this);
            }

            if (this.options.visible !== null) {
                var self = this;
                var di = Math.ceil(this.clipping() / this.options.visible), wh = 0, lt = 0;
                this.list.children('li').each(function(i) {
                    wh += self.dimension(this, di);
                    if (i + 1 < self.first) {
                        lt = wh;
                    }
                });

                this.list.css(this.wh, wh + 'px');
                this.list.css(this.lt, -lt + 'px');
            }

            this.scroll(this.first, false);
        },

        /**
         * Locks the carousel.
         *
         * @method lock
         * @return undefined
         */
        lock: function() {
            this.locked = true;
            this.buttons();
        },

        /**
         * Unlocks the carousel.
         *
         * @method unlock
         * @return undefined
         */
        unlock: function() {
            this.locked = false;
            this.buttons();
        },

        /**
         * Sets the size of the carousel.
         *
         * @method size
         * @return undefined
         * @param s {Number} The size of the carousel.
         */
        size: function(s) {
            if (s !== undefined) {
                this.options.size = s;
                if (!this.locked) {
                    this.buttons();
                }
            }

            return this.options.size;
        },

        /**
         * Checks whether a list element exists for the given index (or index range).
         *
         * @method get
         * @return bool
         * @param i {Number} The index of the (first) element.
         * @param i2 {Number} The index of the last element.
         */
        has: function(i, i2) {
            if (i2 === undefined || !i2) {
                i2 = i;
            }

            if (this.options.size !== null && i2 > this.options.size) {
                i2 = this.options.size;
            }

            for (var j = i; j <= i2; j++) {
                var e = this.get(j);
                if (!e.length || e.hasClass('jcarousel-item-placeholder')) {
                    return false;
                }
            }

            return true;
        },

        /**
         * Returns a jQuery object with list element for the given index.
         *
         * @method get
         * @return jQuery
         * @param i {Number} The index of the element.
         */
        get: function(i) {
            return $('>.jcarousel-item-' + i, this.list);
        },

        /**
         * Adds an element for the given index to the list.
         * If the element already exists, it updates the inner html.
         * Returns the created element as jQuery object.
         *
         * @method add
         * @return jQuery
         * @param i {Number} The index of the element.
         * @param s {String} The innerHTML of the element.
         */
        add: function(i, s) {
            var e = this.get(i), old = 0, n = $(s);

            if (e.length === 0) {
                var c, j = $jc.intval(i);
                e = this.create(i);
                while (true) {
                    c = this.get(--j);
                    if (j <= 0 || c.length) {
                        if (j <= 0) {
                            this.list.prepend(e);
                        } else {
                            c.after(e);
                        }
                        break;
                    }
                }
            } else {
                old = this.dimension(e);
            }

            if (n.get(0).nodeName.toUpperCase() == 'LI') {
                e.replaceWith(n);
                e = n;
            } else {
                e.empty().append(s);
            }

            this.format(e.removeClass(this.className('jcarousel-item-placeholder')), i);

            var di = this.options.visible !== null ? Math.ceil(this.clipping() / this.options.visible) : null;
            var wh = this.dimension(e, di) - old;

            if (i > 0 && i < this.first) {
                this.list.css(this.lt, $jc.intval(this.list.css(this.lt)) - wh + 'px');
            }

            this.list.css(this.wh, $jc.intval(this.list.css(this.wh)) + wh + 'px');

            return e;
        },

        /**
         * Removes an element for the given index from the list.
         *
         * @method remove
         * @return undefined
         * @param i {Number} The index of the element.
         */
        remove: function(i) {
            var e = this.get(i);

            // Check if item exists and is not currently visible
            if (!e.length || (i >= this.first && i <= this.last)) {
                return;
            }

            var d = this.dimension(e);

            if (i < this.first) {
                this.list.css(this.lt, $jc.intval(this.list.css(this.lt)) + d + 'px');
            }

            e.remove();

            this.list.css(this.wh, $jc.intval(this.list.css(this.wh)) - d + 'px');
        },

        /**
         * Moves the carousel forwards.
         *
         * @method next
         * @return undefined
         */
        next: function() {
            if (this.tail !== null && !this.inTail) {
                this.scrollTail(false);
            } else {
                this.scroll(((this.options.wrap == 'both' || this.options.wrap == 'last') && this.options.size !== null && this.last == this.options.size) ? 1 : this.first + this.options.scroll);
            }
        },

        /**
         * Moves the carousel backwards.
         *
         * @method prev
         * @return undefined
         */
        prev: function() {
            if (this.tail !== null && this.inTail) {
                this.scrollTail(true);
            } else {
                this.scroll(((this.options.wrap == 'both' || this.options.wrap == 'first') && this.options.size !== null && this.first == 1) ? this.options.size : this.first - this.options.scroll);
            }
        },

        /**
         * Scrolls the tail of the carousel.
         *
         * @method scrollTail
         * @return undefined
         * @param b {Boolean} Whether scroll the tail back or forward.
         */
        scrollTail: function(b) {
            if (this.locked || this.animating || !this.tail) {
                return;
            }

            this.pauseAuto();

            var pos  = $jc.intval(this.list.css(this.lt));

            pos = !b ? pos - this.tail : pos + this.tail;
            this.inTail = !b;

            // Save for callbacks
            this.prevFirst = this.first;
            this.prevLast  = this.last;

            this.animate(pos);
        },

        /**
         * Scrolls the carousel to a certain position.
         *
         * @method scroll
         * @return undefined
         * @param i {Number} The index of the element to scoll to.
         * @param a {Boolean} Flag indicating whether to perform animation.
         */
        scroll: function(i, a) {
            if (this.locked || this.animating) {
                return;
            }

            this.pauseAuto();
            this.animate(this.pos(i), a);
        },

        /**
         * Prepares the carousel and return the position for a certian index.
         *
         * @method pos
         * @return {Number}
         * @param i {Number} The index of the element to scoll to.
         * @param fv {Boolean} Whether to force last item to be visible.
         */
        pos: function(i, fv) {
            var pos  = $jc.intval(this.list.css(this.lt));

            if (this.locked || this.animating) {
                return pos;
            }

            if (this.options.wrap != 'circular') {
                i = i < 1 ? 1 : (this.options.size && i > this.options.size ? this.options.size : i);
            }

            var back = this.first > i;

            // Create placeholders, new list width/height
            // and new list position
            var f = this.options.wrap != 'circular' && this.first <= 1 ? 1 : this.first;
            var c = back ? this.get(f) : this.get(this.last);
            var j = back ? f : f - 1;
            var e = null, l = 0, p = false, d = 0, g;

            while (back ? --j >= i : ++j < i) {
                e = this.get(j);
                p = !e.length;
                if (e.length === 0) {
                    e = this.create(j).addClass(this.className('jcarousel-item-placeholder'));
                    c[back ? 'before' : 'after' ](e);

                    if (this.first !== null && this.options.wrap == 'circular' && this.options.size !== null && (j <= 0 || j > this.options.size)) {
                        g = this.get(this.index(j));
                        if (g.length) {
                            e = this.add(j, g.clone(true));
                        }
                    }
                }

                c = e;
                d = this.dimension(e);

                if (p) {
                    l += d;
                }

                if (this.first !== null && (this.options.wrap == 'circular' || (j >= 1 && (this.options.size === null || j <= this.options.size)))) {
                    pos = back ? pos + d : pos - d;
                }
            }

            // Calculate visible items
            var clipping = this.clipping(), cache = [], visible = 0, v = 0;
            c = this.get(i - 1);
            j = i;

            while (++visible) {
                e = this.get(j);
                p = !e.length;
                if (e.length === 0) {
                    e = this.create(j).addClass(this.className('jcarousel-item-placeholder'));
                    // This should only happen on a next scroll
                    if (c.length === 0) {
                        this.list.prepend(e);
                    } else {
                        c[back ? 'before' : 'after' ](e);
                    }

                    if (this.first !== null && this.options.wrap == 'circular' && this.options.size !== null && (j <= 0 || j > this.options.size)) {
                        g = this.get(this.index(j));
                        if (g.length) {
                            e = this.add(j, g.clone(true));
                        }
                    }
                }

                c = e;
                d = this.dimension(e);
                if (d === 0) {
                    throw new Error('jCarousel: No width/height set for items. This will cause an infinite loop. Aborting...');
                }

                if (this.options.wrap != 'circular' && this.options.size !== null && j > this.options.size) {
                    cache.push(e);
                } else if (p) {
                    l += d;
                }

                v += d;

                if (v >= clipping) {
                    break;
                }

                j++;
            }

             // Remove out-of-range placeholders
            for (var x = 0; x < cache.length; x++) {
                cache[x].remove();
            }

            // Resize list
            if (l > 0) {
                this.list.css(this.wh, this.dimension(this.list) + l + 'px');

                if (back) {
                    pos -= l;
                    this.list.css(this.lt, $jc.intval(this.list.css(this.lt)) - l + 'px');
                }
            }

            // Calculate first and last item
            var last = i + visible - 1;
            if (this.options.wrap != 'circular' && this.options.size && last > this.options.size) {
                last = this.options.size;
            }

            if (j > last) {
                visible = 0;
                j = last;
                v = 0;
                while (++visible) {
                    e = this.get(j--);
                    if (!e.length) {
                        break;
                    }
                    v += this.dimension(e);
                    if (v >= clipping) {
                        break;
                    }
                }
            }

            var first = last - visible + 1;
            if (this.options.wrap != 'circular' && first < 1) {
                first = 1;
            }

            if (this.inTail && back) {
                pos += this.tail;
                this.inTail = false;
            }

            this.tail = null;
            if (this.options.wrap != 'circular' && last == this.options.size && (last - visible + 1) >= 1) {
                var m = $jc.intval(this.get(last).css(!this.options.vertical ? 'marginRight' : 'marginBottom'));
                if ((v - m) > clipping) {
                    this.tail = v - clipping - m;
                }
            }

            if (fv && i === this.options.size && this.tail) {
                pos -= this.tail;
                this.inTail = true;
            }

            // Adjust position
            while (i-- > first) {
                pos += this.dimension(this.get(i));
            }

            // Save visible item range
            this.prevFirst = this.first;
            this.prevLast  = this.last;
            this.first     = first;
            this.last      = last;

            return pos;
        },

        /**
         * Animates the carousel to a certain position.
         *
         * @method animate
         * @return undefined
         * @param p {Number} Position to scroll to.
         * @param a {Boolean} Flag indicating whether to perform animation.
         */
        animate: function(p, a) {
            if (this.locked || this.animating) {
                return;
            }

            this.animating = true;

            var self = this;
            var scrolled = function() {
                self.animating = false;

                if (p === 0) {
                    self.list.css(self.lt,  0);
                }

                if (!self.autoStopped && (self.options.wrap == 'circular' || self.options.wrap == 'both' || self.options.wrap == 'last' || self.options.size === null || self.last < self.options.size || (self.last == self.options.size && self.tail !== null && !self.inTail))) {
                    self.startAuto();
                }

                self.buttons();
                self.notify('onAfterAnimation');

                // This function removes items which are appended automatically for circulation.
                // This prevents the list from growing infinitely.
                if (self.options.wrap == 'circular' && self.options.size !== null) {
                    for (var i = self.prevFirst; i <= self.prevLast; i++) {
                        if (i !== null && !(i >= self.first && i <= self.last) && (i < 1 || i > self.options.size)) {
                            self.remove(i);
                        }
                    }
                }
            };

            this.notify('onBeforeAnimation');

            // Animate
            if (!this.options.animation || a === false) {
                this.list.css(this.lt, p + 'px');
                scrolled();
            } else {
                var o = !this.options.vertical ? (this.options.rtl ? {'right': p} : {'left': p}) : {'top': p};
                // Define animation settings.
                var settings = {
                    duration: this.options.animation,
                    easing:   this.options.easing,
                    complete: scrolled
                };
                // If we have a step callback, specify it as well.
                if ($.isFunction(this.options.animationStepCallback)) {
                    settings.step = this.options.animationStepCallback;
                }
                // Start the animation.
                this.list.animate(o, settings);
            }
        },

        /**
         * Starts autoscrolling.
         *
         * @method auto
         * @return undefined
         * @param s {Number} Seconds to periodically autoscroll the content.
         */
        startAuto: function(s) {
            if (s !== undefined) {
                this.options.auto = s;
            }

            if (this.options.auto === 0) {
                return this.stopAuto();
            }

            if (this.timer !== null) {
                return;
            }

            this.autoStopped = false;

            var self = this;
            this.timer = window.setTimeout(function() { self.next(); }, this.options.auto * 1000);
        },

        /**
         * Stops autoscrolling.
         *
         * @method stopAuto
         * @return undefined
         */
        stopAuto: function() {
            this.pauseAuto();
            this.autoStopped = true;
        },

        /**
         * Pauses autoscrolling.
         *
         * @method pauseAuto
         * @return undefined
         */
        pauseAuto: function() {
            if (this.timer === null) {
                return;
            }

            window.clearTimeout(this.timer);
            this.timer = null;
        },

        /**
         * Sets the states of the prev/next buttons.
         *
         * @method buttons
         * @return undefined
         */
        buttons: function(n, p) {
            if (n == null) {
                n = !this.locked && this.options.size !== 0 && ((this.options.wrap && this.options.wrap != 'first') || this.options.size === null || this.last < this.options.size);
                if (!this.locked && (!this.options.wrap || this.options.wrap == 'first') && this.options.size !== null && this.last >= this.options.size) {
                    n = this.tail !== null && !this.inTail;
                }
            }

            if (p == null) {
                p = !this.locked && this.options.size !== 0 && ((this.options.wrap && this.options.wrap != 'last') || this.first > 1);
                if (!this.locked && (!this.options.wrap || this.options.wrap == 'last') && this.options.size !== null && this.first == 1) {
                    p = this.tail !== null && this.inTail;
                }
            }

            var self = this;

            if (this.buttonNext.size() > 0) {
                this.buttonNext.unbind(this.options.buttonNextEvent + '.jcarousel', this.funcNext);

                if (n) {
                    this.buttonNext.bind(this.options.buttonNextEvent + '.jcarousel', this.funcNext);
                }

                this.buttonNext[n ? 'removeClass' : 'addClass'](this.className('jcarousel-next-disabled')).attr('disabled', n ? false : true);

                if (this.options.buttonNextCallback !== null && this.buttonNext.data('jcarouselstate') != n) {
                    this.buttonNext.each(function() { self.options.buttonNextCallback(self, this, n); }).data('jcarouselstate', n);
                }
            } else {
                if (this.options.buttonNextCallback !== null && this.buttonNextState != n) {
                    this.options.buttonNextCallback(self, null, n);
                }
            }

            if (this.buttonPrev.size() > 0) {
                this.buttonPrev.unbind(this.options.buttonPrevEvent + '.jcarousel', this.funcPrev);

                if (p) {
                    this.buttonPrev.bind(this.options.buttonPrevEvent + '.jcarousel', this.funcPrev);
                }

                this.buttonPrev[p ? 'removeClass' : 'addClass'](this.className('jcarousel-prev-disabled')).attr('disabled', p ? false : true);

                if (this.options.buttonPrevCallback !== null && this.buttonPrev.data('jcarouselstate') != p) {
                    this.buttonPrev.each(function() { self.options.buttonPrevCallback(self, this, p); }).data('jcarouselstate', p);
                }
            } else {
                if (this.options.buttonPrevCallback !== null && this.buttonPrevState != p) {
                    this.options.buttonPrevCallback(self, null, p);
                }
            }

            this.buttonNextState = n;
            this.buttonPrevState = p;
        },

        /**
         * Notify callback of a specified event.
         *
         * @method notify
         * @return undefined
         * @param evt {String} The event name
         */
        notify: function(evt) {
            var state = this.prevFirst === null ? 'init' : (this.prevFirst < this.first ? 'next' : 'prev');

            // Load items
            this.callback('itemLoadCallback', evt, state);

            if (this.prevFirst !== this.first) {
                this.callback('itemFirstInCallback', evt, state, this.first);
                this.callback('itemFirstOutCallback', evt, state, this.prevFirst);
            }

            if (this.prevLast !== this.last) {
                this.callback('itemLastInCallback', evt, state, this.last);
                this.callback('itemLastOutCallback', evt, state, this.prevLast);
            }

            this.callback('itemVisibleInCallback', evt, state, this.first, this.last, this.prevFirst, this.prevLast);
            this.callback('itemVisibleOutCallback', evt, state, this.prevFirst, this.prevLast, this.first, this.last);
        },

        callback: function(cb, evt, state, i1, i2, i3, i4) {
            if (this.options[cb] == null || (typeof this.options[cb] != 'object' && evt != 'onAfterAnimation')) {
                return;
            }

            var callback = typeof this.options[cb] == 'object' ? this.options[cb][evt] : this.options[cb];

            if (!$.isFunction(callback)) {
                return;
            }

            var self = this;

            if (i1 === undefined) {
                callback(self, state, evt);
            } else if (i2 === undefined) {
                this.get(i1).each(function() { callback(self, this, i1, state, evt); });
            } else {
                var call = function(i) {
                    self.get(i).each(function() { callback(self, this, i, state, evt); });
                };
                for (var i = i1; i <= i2; i++) {
                    if (i !== null && !(i >= i3 && i <= i4)) {
                        call(i);
                    }
                }
            }
        },

        create: function(i) {
            return this.format('<li></li>', i);
        },

        format: function(e, i) {
            e = $(e);
            var split = e.get(0).className.split(' ');
            for (var j = 0; j < split.length; j++) {
                if (split[j].indexOf('jcarousel-') != -1) {
                    e.removeClass(split[j]);
                }
            }
            e.addClass(this.className('jcarousel-item')).addClass(this.className('jcarousel-item-' + i)).css({
                'float': (this.options.rtl ? 'right' : 'left'),
                'list-style': 'none'
            }).attr('jcarouselindex', i);
            return e;
        },

        className: function(c) {
            return c + ' ' + c + (!this.options.vertical ? '-horizontal' : '-vertical');
        },

        dimension: function(e, d) {
            var el = $(e);

            if (d == null) {
                return !this.options.vertical ?
                    ((el.innerWidth() +
                        $jc.intval(el.css('margin-left')) +
                        $jc.intval(el.css('margin-right')) +
                        $jc.intval(el.css('border-left-width')) +
                        $jc.intval(el.css('border-right-width'))) || $jc.intval(this.options.itemFallbackDimension)) :
                    ((el.innerHeight() +
                        $jc.intval(el.css('margin-top')) +
                        $jc.intval(el.css('margin-bottom')) +
                        $jc.intval(el.css('border-top-width')) +
                        $jc.intval(el.css('border-bottom-width'))) || $jc.intval(this.options.itemFallbackDimension));
            } else {
                var w = !this.options.vertical ?
                    d - $jc.intval(el.css('marginLeft')) - $jc.intval(el.css('marginRight')) :
                    d - $jc.intval(el.css('marginTop')) - $jc.intval(el.css('marginBottom'));

                $(el).css(this.wh, w + 'px');

                return this.dimension(el);
            }
        },

        clipping: function() {
            return !this.options.vertical ?
                this.clip[0].offsetWidth - $jc.intval(this.clip.css('borderLeftWidth')) - $jc.intval(this.clip.css('borderRightWidth')) :
                this.clip[0].offsetHeight - $jc.intval(this.clip.css('borderTopWidth')) - $jc.intval(this.clip.css('borderBottomWidth'));
        },

        index: function(i, s) {
            if (s == null) {
                s = this.options.size;
            }

            return Math.round((((i-1) / s) - Math.floor((i-1) / s)) * s) + 1;
        }
    });

    $jc.extend({
        /**
         * Gets/Sets the global default configuration properties.
         *
         * @method defaults
         * @return {Object}
         * @param d {Object} A set of key/value pairs to set as configuration properties.
         */
        defaults: function(d) {
            return $.extend(defaults, d || {});
        },

        intval: function(v) {
            v = parseInt(v, 10);
            return isNaN(v) ? 0 : v;
        },

        windowLoaded: function() {
            windowLoaded = true;
        },

        isSafari: function() {
            var ua = navigator.userAgent.toLowerCase(),
                match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || [],
                browser = match[1] || "";

            return browser === 'webkit';
        }
    });

    /**
     * Creates a carousel for all matched elements.
     *
     * @example $("#mycarousel").jcarousel();
     * @before <ul id="mycarousel" class="jcarousel-skin-name"><li>First item</li><li>Second item</li></ul>
     * @result
     *
     * <div class="jcarousel-skin-name">
     *   <div class="jcarousel-container">
     *     <div class="jcarousel-clip">
     *       <ul class="jcarousel-list">
     *         <li class="jcarousel-item-1">First item</li>
     *         <li class="jcarousel-item-2">Second item</li>
     *       </ul>
     *     </div>
     *     <div disabled="disabled" class="jcarousel-prev jcarousel-prev-disabled"></div>
     *     <div class="jcarousel-next"></div>
     *   </div>
     * </div>
     *
     * @method jcarousel
     * @return jQuery
     * @param o {Hash|String} A set of key/value pairs to set as configuration properties or a method name to call on a formerly created instance.
     */
    $.fn.jcarousel = function(o) {
        if (typeof o == 'string') {
            var instance = $(this).data('jcarousel'), args = Array.prototype.slice.call(arguments, 1);
            return instance[o].apply(instance, args);
        } else {
            return this.each(function() {
                var instance = $(this).data('jcarousel');
                if (instance) {
                    if (o) {
                        $.extend(instance.options, o);
                    }
                    instance.reload();
                } else {
                    $(this).data('jcarousel', new $jc(this, o));
                }
            });
        }
    };

})(jQuery);

;/*
* jQuery Facebook plugin
* @author: Massimiliano Balestrieri
* @version: 2.0.0
*/
(function ($) {

  var Flags = {
    facebook: false,
    fbAsyncInit: false
  };

  var D3fb = function (el, o) {
    var that = el, _lang = $('html').attr('lang'), _w = 90, _conf = {};

    if ($(that).data("fb")) {
      //console.log("gi inizializzato");
      return;
    } else {
      $(that).data("fb", true);
    }

    if (o && o.additionalOmnParam !== undefined && o.additionalOmnParam !== null && o.additionalOmnParam !== '') {
      $(that).data('addOmnParam', o.additionalOmnParam);
    }
    if ($('.fb-omni', that).length > 0) {
      $(that).data('addOmnParam', $('.fb-omni', that).text());
    }

    var _callback = function (href, widget) {
      var compFolder = href;
      var evar = 'facebook like';
      var sendOmn = false;
      var addOmnParam = '';
      var jElem = $(widget.dom).parent();

      /*CCTracking*/
      if (window.Deltatre && window.Deltatre.Uefacom && window.Deltatre.Uefacom.ccTracking) {
        var ccT = window.Deltatre.Uefacom.ccTracking;
        if (ccT.page_type != "" && ccT.page_id != "") {
          ccT.trackshare(ccT.page_type, ccT.page_id, 'facebook');
        }
      };
      /*END CCTracking*/

      if (window.SCW && SCW.Active) {

        if (jElem.data('addOmnParam')) {
          addOmnParam = jElem.data('addOmnParam');
        }

//        if (addOmnParam == '') {
//          if (SCW.CustomSocialNetwork && SCW.CustomSocialNetwork.hp != null && SCW.CustomSocialNetwork.hp != undefined && SCW.CustomSocialNetwork.hp != '' && (s.prop5 == 'homepage' || s.prop5 == 'hub')) {
//            evar = evar + ' - ' + SCW.CustomSocialNetwork.hp;
//            sendOmn = true;
//          } else {
//            if (SCW.CustomSocialNetwork && SCW.CustomSocialNetwork.valfb != null && SCW.CustomSocialNetwork.valfb != undefined && SCW.CustomSocialNetwork.valfb != '') {
//              evar = evar + ' - ' + SCW.CustomSocialNetwork.valfb;
//              sendOmn = true;
//            } else {
//              if (s.prop5 != null && s.prop5 !== undefined && s.prop5 != '') {
//                evar += ' - ' + s.prop5;
//                sendOmn = true;
//              }
//            }
//          }
//        } else {
//          evar = evar + ' - ' + addOmnParam;
//          sendOmn = true;
//        }


        if (sendOmn == true) {
          SCW.TL(this, 'o', 'Tool Used',
							{
							  linkTrackVars: 'events,eVar43',
							  linkTrackEvents: 'event20',
							  events: 'event20',
							  eVar43: evar
							});
        }
      }
    };

    var _url = location.href;

    if (location.search !== '') {
      _url = _url.split('?')[0];
    }

    //AB: da rimuovere controllo stupido su index-beta!!
    if (_url.indexOf('/videoid=') === -1 && _url.match(/\/index.html$/) === null) {  // url doesn't end with /index.html
      if (_url.match(/\/index-beta.html$/) === null) { // url doesn't end with /index-beta.html
        if (_url.match(/\/$/) === null) { // url doesn't end with / (slash)
          _url += '/';
        }
        _url += 'index.html';
      } else {
        var x = _url.indexOf('-beta.html');
        _url = _url.substring(0, x) + ".html"
      }
    }

    var _o = {
      SDK: '/' + '/connect.facebook.net/{lang}/all.js',
      url: _url,
      uiculture: 'en_US',
      additionalOmnParam: '',
      app_id: '197885243570897',
      like: {
        layout: 'button_count',
        showfaces: false,
        width: false
      }
    };

    var _facebook = function () {
      //singleton sul caricamento dello script - elemento obbligatorio #fb-root. anche twitter si potrebbe caricare solo alla presenza di un elemento
      //bug su ie da ip locali : https://github.com/facebook/connect-js/issuesearch?state=open&q=ie8#issue/106
      if (!Flags.facebook) {
        Flags.facebook = true;

        var fbinit = null;
        if (typeof window.fbAsyncInit === 'function') {
          fbinit = window.fbAsyncInit;
        }

        window.fbAsyncInit = function () {

          if (typeof fbinit === 'function') {
            fbinit();
          } else {
            FB.init({ appId: '197885243570897', status: true, cookie: true, xfbml: true });
          }

          //reset width - FB BUG
          FB.Event.subscribe('edge.remove', function (href, widget) {
            setTimeout(function () {
              $(widget.dom).find("iframe").css("width", _w + "px");
            }, 500);
          });
          FB.Event.subscribe('edge.create', function (href, widget) {
            _callback(href, widget);
          });
          Flags.fbAsyncInit = true;
        };

        (function () {
          var js, fjs = document.getElementsByTagName('script')[0];
          if (document.getElementById('facebook-jssdk')) { return; }
          js = document.createElement('script');
          js.id = 'facebook-jssdk';
          js.src = document.location.protocol + _o.SDK.replace('{lang}', _o.uiculture); // +'#xfbml=1&appId=241194762579707';
          fjs.parentNode.insertBefore(js, fjs);
        } ());
      }
      if (Flags.fbAsyncInit) {
        FB.XFBML.parse(that);
      }

    }
	  , _getCultureInfo = function () {
	    if (!_lang)
	      return 'en_US';
	    switch (_lang.toLowerCase()) {
	      case 'ua':
	      case 'uk':
	        return 'uk_UA';
	      case 'ja':
	      case 'jp':
	        return 'ja_JP';
	      case 'zh':
	      case 'cn':
	        return 'zh_CN';
	      case 'ko':
	      case 'kr':
	        return 'ko_KR';
	      case 'en':
	        return 'en_US';
	      default:
	        return _lang.toLowerCase() + '_' + _lang.toUpperCase();
	    }
	  }
	  , _buttonWidth = function () {
	    if (_o.like.width)
	      _w = _o.like.width;
	    switch (_lang.toLowerCase()) {
	      case 'ru':
	      case 'ua':
	        _w = 150;
	        break;
	      case 'it':
	      case 'pt':
	        _w = 120;
	        break;
	      case 'de':
	      case 'jp':
	        _w = 115;
	        break;
	      case 'es':
	      case 'fr':
	      case 'pl':
	      case 'kr':
	        _w = 110;
	        break;
	      case 'cn':
	      case 'en':
	        _w = 90;
	        break;
	    }
	  };

    //main
    if ($('body').attr('id') != 'uefachampionsleague' && $('body').attr('id') != 'uefaeuropaleague') {
      if ($(that).parents('.d3cmsBCbot').length > 0) {
        that.innerHTML = "";
        return false;
      }
    }
    $.extend(true, o, $(that).data('options') || {}); // FB: non sono certo che sia safe, ma  l'unica maniera che ho trovato per recuperare i data-options quando d3fb viene chiamato da parsers.generic
    $.extend(true, _o, o || {});
    _o.uiculture = _getCultureInfo();
    _o.url = _o.url.indexOf('http') == -1 ? 'http:/' + '/' + location.host + _o.url : _o.url;
    _buttonWidth();
    that.innerHTML = '<fb:like href="' + _o.url + '" layout="' + _o.like.layout + '" show_faces="' + _o.like.showfaces + '" width="' + _w + '"/>';
    _facebook();

  };

  $.fn.d3fb = function (o) {

    if (location.host.indexOf('uefa.org') > -1 && location.href.indexOf('/uefa-best-player-award/') === -1 && location.href.indexOf('/uefa-best-women-player-award/') === -1) {
      return false;
    }

    return this.each(function (n) {
      new D3fb(this, o);
    });
  };

  /*
  $(document).ready(function() {
  if ($('.nolike').length === 0) {
  $('.fb-button, .fblike').d3fb();
  }
  });
  */

})(jQuery);

/*
* jQuery Twitter plugin
* @author: Massimiliano Balestrieri
* @version: 2.0.0
*/
(function ($) {

  var _static = false;

  var D3twitter = function (el, o) {
    var that = el, _lang = $('html').attr('lang');
    if ($(that).data("D3twitter")) {
      //console.log("gi inizializzato");
      return;
    } else {
      $(that).data("D3twitter", true);
    }

    var _o = {
      url: location.href,
      counturl: location.href,
      API: 'https:/' + '/platform.twitter.com/widgets.js',
      datacount: 'horizontal',
      datatext: null,
      via: 'UEFAcom'
    };

    var _twitter = function () {
      //singleton sul caricamento dello script - elemento obbligatorio #fb-root. anche twitter si potrebbe caricare solo alla presenza di un elemento
      //bug su ie da ip locali : https://github.com/facebook/connect-js/issuesearch?state=open&q=ie8#issue/106
      if (!_static) {
        _static = true;
        window.twttr = (function (d, s, id) {
          var t, js, fjs = d.getElementsByTagName(s)[0];
          if (d.getElementById(id)) return; js = d.createElement(s); js.id = id;
          js.src = "https://platform.twitter.com/widgets.js"; fjs.parentNode.insertBefore(js, fjs);
          return window.twttr || (t = { _e: [], ready: function (f) { t._e.push(f) } });
        } (document, "script", "twitter-wjs"));

        function tweetIntentToTrack(intentEvent) {
          if (!intentEvent) return;
          /*CCTracking*/
          if (window.Deltatre && window.Deltatre.Uefacom && window.Deltatre.Uefacom.ccTracking) {
            var ccT = window.Deltatre.Uefacom.ccTracking;
            if (ccT.page_type != "" && ccT.page_id != "") {
              ccT.trackshare(ccT.page_type, ccT.page_id, 'twitter');
            }
          };
          /*END CCTracking*/
        };

        function tweetIntentClick(intentEvent) {
          // console.log('click event');
        };

        twttr.ready(function (twttr) {
          // Now bind our custom intent events
          twttr.events.bind('tweet', tweetIntentToTrack);
        });

      }

      var _a = $('<a />').attr({
        href: 'http:/' + '/twitter.com/share',
        'data-url': _o.url.replace(/^(https?:\/\/)en\.uefa\./i, "$1www.uefa."), //en punta www,
        'data-counturl': _o.counturl.replace(/^(https?:\/\/)en\.uefa\./i, "$1www.uefa."), //en punta www,
        'data-count': _o.datacount,
        'data-lang': _lang.replace(/en|pt|ru|pl|uk|cn/, 'en'),
        'data-via': _o.via
      }).addClass('twitter-share-button');
      if (_o.datatext != null) {
        _a.attr('data-text', _o.datatext);
      }

      $(that).append(_a);
      //twitter al caricamento dell'api renderizza automaticamente tutti i tag a.twitter-share-button
      //se l'elemento (DOM) conosce gi window.twttr vuol dire che  stato inserito via ajax
      //twttr.TweetButton has been deprecated: http://stackoverflow.com/questions/6206471/re-render-tweet-button-via-js
      //if (window.twttr) _render();
      if (window.twttr && window.twttr.widgets !== undefined) { window.twttr.widgets.load(); }
    }
	, _render = function () {
	  //AHAH: - il render esplicito non  necessario se l'elemento  presente al caricamento. TEST
	  //http://forrst.com/posts/Render_Tweet_Button_in_AJAX_Loaded_Content-7cx
	  //twttr.TweetButton has been deprecated: http://stackoverflow.com/questions/6206471/re-render-tweet-button-via-js
	  //http://www.seanmccambridge.com/articles/page/re-rendering-facebook-twitter-and-sharethis-social-buttons-when-adding-new-/
	  //da verificare la rimozione di 'sto schifo
	  //e l'utilizzo dell'iframe:https://dev.twitter.com/docs/tweet-button#using-an-iframe
	  //appena c' un attimo di calma :|
	  try {

	    //	    var _a = $("a", that).get(0)
	    //	    var loadedTweetButton = new twttr.TweetButton(_a);
	    //	    loadedTweetButton.render();

	    (function () {
	      var twitterWidgets = document.createElement("script");
	      twitterWidgets.type = "text/javascript";
	      twitterWidgets.async = true;
	      twitterWidgets.src = "https://platform.twitter.com/widgets.js";
	      document.getElementsByTagName("head")[0].appendChild(twitterWidgets);
	    })();

	  } catch (e) { }
	};

    //main
    $.extend(true, _o, o || {});
    _o.url = _o.url.indexOf('http') == -1 ? 'http:/' + '/' + location.host + _o.url : _o.url;
    _o.counturl = _o.counturl.indexOf('http') == -1 ? 'http:/' + '/' + location.host + _o.counturl : _o.counturl;
    _o.via = location.hostname.indexOf('uefa.org') > -1 ? 'UEFAorg' : 'UEFAcom';
    _twitter();
  };

  $.fn.d3twitter = function (o) {

    if (location.host.indexOf('uefa.org') > -1 && location.href.indexOf('/uefa-best-player-award/') === -1 && location.href.indexOf('/uefa-best-women-player-award/') === -1) {
      return false;
    }

    return this.each(function (n) {

      var _url = o && o.url ? o.url : location.href;
      var _this = this;

      var _getPaddedNewsId = function (p) {

        p = p.toString();
        if (p.length % 2 != 0)
          p = '0' + p;
        var _l = p.length, _x = 0;
        var result = '';
        for (var i = 0; i < _l - 1; i = i + 2) {
          result += 'n' + (++_x) + '=' + p.substr(i, 2) + '/';
        }
        return result.substr(0, result.length - 1);
      };

      var newsid = $(this).attr('data-newsid');
      if (newsid != undefined) {
        var paddedPath = _getPaddedNewsId(newsid);
        var url = '/library/meta/' + paddedPath + '/_news.json';

        $.ajax({
          url: url,
          dataType: 'json',
          success: function (res) {
            if (res) {
              if (res.shorturl && res.shorturl != '' && res.url && res.url != '') {
                o.url = res.shorturl;
                o.counturl = res.url.split('#')[0];
              }
              else if (res.url && res.url != '') {
                o.url = res.url.split('#')[0];
                o.counturl = res.url.split('#')[0];
              }
            }

            /* EURO EXCEPTION BECAUSE SHORTENED URLs DO NOT REFERS TO THE URLs REVRITE  */
            if (o.counturl!==undefined) {
              if (o.counturl.indexOf('/uefaeuro/') != -1 || o.counturl.indexOf('/uefaeuro-finals/') != -1) {
                o.url = res.url.split('#')[0];
              }
            }


            new D3twitter(_this, o);
          },
          error: function (xhr, ajaxOptions, thrownError) {
            //todo: raise error!
            o.url = location.origin + location.pathname;
            o.counturl = location.origin + location.pathname;
            new D3twitter(_this, o);
          }
        });

      }
      else {
        new D3twitter(_this, o); //no json file related newsid, use long url
      }
      //new D3twitter(this, o);
    });
  };
})(jQuery);

;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

/*
DEPENDS ON jquery.socials.source.js
  - $.fn.d3fb
*/

(function ($) {

  'use strict';

  $.fn.fblazy = function (options) {

    return this.each(function () {

      var that = this;
      var _o = $.extend({
        selectors: {
          wrapper: '.newsThumbItem:eq(0)',
          url: 'a.newsThumb',
          handler: '.fblazy',
          target: '.fblazy-hover',
          omni: '.fb-omni'
        }
      }, options), _s = _o.selectors;

      var _wrapper = $(that).parents(_s.wrapper);
      var _url = $(_s.url, _wrapper).attr("href"); //NB: SET THIS BEFORE AJAX IMPLEMENTATION
      var _hnd = $(_s.handler, that);
      var _target = $(_s.target, that);

      $(that).one("mouseenter", function () {
        $(_target).d3fb({
          url: _url,
          additionalOmnParam: $(_s.omni, _wrapper).text()
        });
      });
      $(that).slowhover(function () {
        $(_hnd).hide();
        $(_target).show();
      }, function () {
        $(_hnd).show();
        $(_target).hide();
      });

    });


  };


} (jQuery));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

/*
Load pluck framework at first call.

Used by:
\js\d3pg\plugins\pluck\d3pg.pluck.js
\js\jquery\canon\overview.pluck.source.js

Works like d3.LazyScript + jsInjectionTable

Settings/Metadata are read from footer (centralized).
\code\Templates\Elements\Footers\Footer.xslt
Pluck at this moment is active in all uefa.com site.


TEST:
/uefachampionsleague/season=2014/matches/round=2000479/match=2011769/index.html
*/

(function ($, win, undefined) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var util = d3.util;
  //var trace = d3.Trace;

  // Default configuration properties.
  var defaults = {
    //TODO: lang + ambienti - move this in html
    js: undefined,
    sdk: undefined,
    libs: undefined,
    css: undefined
  };

  /*
  * The PluckLoader singleton class.
  *
  */
  d3.PluckLoader = function () {


    /* ------------------------- */
    /* Variables */
    var _proto = d3.PluckLoader.prototype,
        _isready = false,
        _opt;



    /* ------------------------- */
    /* singleton logic */
    if (_proto._singletonInstance) {
      return _proto._singletonInstance;
    }

    _proto._singletonInstance = this;


    /* ------------------------- */
    /* Declaring private functions */
    var _initialize, _onReady;


    /* ------------------------- */
    //Public Functions

    this.whenReady = function (job) {
      //debugger;
      if ($.isFunction(job)) {
        if (_isready) {
          job();
        } else {
          _proto.jobs.push(job);
        }
      }

    };




    /* ------------------------- */
    //Private Functions

    _initialize = function () {
      //debugger;
      var $meta = $('#js-uefa-pluck-loader'), _meta;
      if ($meta.length > 0) {

        if ($.metadata) {
          $.metadata.setType('attr', 'data-options');
          _meta = $meta.metadata();
        } else {
          _meta = $meta.data('options');
        }


        if (_meta !== undefined) {

          var _opt = $.extend(true, {}, defaults, _meta || {});

          //d3.Trace(_opt);

          if (_opt.css) {
            util.prependStyle(_opt.css, 'd3.css.pluck.libs');
          }
          
          //retrocompatibility
          if (_opt.libs && $.metadata) {
            util.appendScript(_opt.libs, function () {
              
            }, 'd3.js.pluck.libs');
          } 

          if (_opt.js && _opt.sdk) {
            util.appendScript(_opt.js, function () {
              util.appendScript(_opt.sdk, function () {
                _onReady();
              }, 'd3.js.pluck.sdk');
            }, 'd3.js.pluck.js');
          }


        }

      }

    };



    _onReady = function () {

      while (_proto.jobs.length) {
        _proto.jobs.shift().call();
      }

      _isready = true;

    };


    //TODO: check class on body .js-pluck-enabled. Wait rebuild of all pages 
    //initialize singleton
    if (win.PluckSDK === undefined || d3.D3Pluck === undefined) {
      _initialize();
    } else {
      _onReady();
    }

  };

  d3.PluckLoader.prototype.jobs = [];


} (jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, newcap: true */

(function ($, win, undefined) {

  'use strict';


  /**
  * hoverSlide replace imgRollover 1.0.0. A simple rollover effect plugin
  * 
  * Launch  : October 2013
  * Version : 2.0.0
  * Released: Massimiliano Balestrieri
  */
  var hoverSlide = function($dom, conf) {

    /* ------------------------- */
    /* Variables */
    var height = parseInt($dom.closest(conf.parent).css("height"), 10) - 1;
    var elheight = (conf.elheight === undefined) ? parseInt($dom.css("height"), 10) : conf.elheight;
    var heightStart = (conf.heightStart === undefined) ? parseInt($dom.css("top"), 10) : conf.heightStart;

    /* ------------------------- */
    /* Declaring private functions */
    var _in, _out, _animate;
    /* ------------------------- */
    //Public Functions
    this.init = function () {
      if ($dom.hasClass(conf.classNoOffect)) {
        return;
      }

      $dom.hover(_in, _out);
    };

    /* ------------------------- */
    //Private Functions
    _in = function () {

      _animate({
        top: "0px",
        height: height + "px"
      });

      if ($.isFunction(conf.opening)) {
        conf.opening($dom);
      }

    };

    _out = function () {

      _animate({
        top: heightStart + "px",
        height: elheight + "px"
      });

      if ($.isFunction(conf.closing)) {
        conf.closing($dom);
      }
    };

    _animate = function (css) {

      if ($dom.is(':animated')) {
        $dom.stop();
      }

      $dom.animate(css, conf.speed, conf.openCb);

    };

  };

  $.fn.hoverSlide = function (conf) {

    //console.log(this);

    // Default configuration
    var defaultConf = {
      speed: 100,
      classNoOffect: 'noeffect',
      parent: 'div.vThumbContainer',
      comment: 'div.vComment',
      title: 'div.vTitle',
      openCb: undefined,
      closeCb: undefined,
      heightStart: undefined,
      elheight: undefined
    };

    $.extend(defaultConf, conf);

    function GetLineHeight(obj) {
      if (obj.length > 0) {
        return obj.height() / parseInt(obj.css('lineHeight').replace('px', ''), 10);
      }
    }

    function stringCut(s, len) {
      if (s.length > len) {
        var str = s.substr(0, len);
        return str.substr(0, str.lastIndexOf(" ")) + '...';
      }
    }

    return this.each(function () {

      var $dom = $(this);
      var $de = {};
      $de.title = $(defaultConf.title, $dom);
      $de.comment = $(defaultConf.comment, $dom);

      var hideClass = $dom.hasClass('hideComment');
      if (hideClass) {
        var t = $de.title;
        var c = $de.comment;

        var titleLines = GetLineHeight(t);
        var commentLines = GetLineHeight(c);

        if (typeof commentLines === 'number' && typeof titleLines === 'number') {
          var chr;
          switch (titleLines) {
            case 1:
              chr = 135;
              break;
            case 2:
              chr = 110;
              break;
            default:
              chr = 100;
          }
          var s = stringCut($de.comment.text(), chr);
          $de.comment.text(s);
        }
      }

      var obj = new hoverSlide($dom, defaultConf);
      obj.init();

    });

  };

  //retrocompatibility : to be removed
  //when all xslt involved will be rebuilt
  $.fn.imgRollover = $.fn.hoverSlide;

} (jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre, console */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

(function ($, win, undefined) {

  'use strict';

  $.fn.photoslideRewriteUrl = function () {
   
    return this.each(function () {
      var _href = this.href;
      if (_href.indexOf("photoid") !== -1) {
        var regex = new RegExp('photoid=[0-9]*');
        var _id = regex.exec(this.href);
        if (_id && _id[0] && _id[0].indexOf("photoid=") !== -1) {
          _id = _id.pop().replace("photoid=", "");
          if (_href.indexOf("/uefaeuro/photos/") !== -1 || _href.indexOf("/uefachampionsleague/photos/") !== -1) {
            _href = _href.replace("photoid=" + _id + ".html", "latest/photo.html#" + _id);
          } else {
            _href = _href.replace("photoid=" + _id + ".html", "photo.html#" + _id);
          }

          this.href = _href;
        }
      }
    });
  };


  $.fn.photoslideRewriteUrlFromImageSrc = function () {

    
    return this.each(function () {

      var _img = $(this).find("img"), _input = $(this).find("input.src"), _attr, _target;

      if (_img.length > 0) {
        _target = _img;
        if (_target.attr('data-src') !== undefined) {
          _attr = 'data-src';
        } else {
          _attr = 'src';
        }
      } else if (_input.length > 0) {
        _target = _input;
        _attr = 'value';
      }

      if (_img.length > 0 || _input.length > 0) {
        try {


          var regex = new RegExp('[0-9]*\\_(w4|w6|s5|s2).jpg');
          var _src = _target.attr(_attr);

          //MultimediaFiles/Photo/competitions/Comp_Matches/01/67/37/84/1673784_w4.jpg
          var _id = regex
                    .exec(_src)
                    .shift()
                    .replace("_w4.jpg", "")
                    .replace("_w6.jpg", "")
                    .replace("_s5.jpg", "")
                    .replace("_s2.jpg", "");


          this.href = this.href + "#" + _id;
        } catch (e) {
          if (console && console.log) {
            console.log(e);
          }

        }

      }
    });
  };


  $(document).ready(function () {
    //PHOTOSTREAM URL REWRITE:
    $(".photoGrid_4cols a.newsThumb, .photoGrid_2cols a.newsThumb, .jboxdiv a.newsThumb, .rewritePhotosById a.newsThumb").photoslideRewriteUrl();
    //PHOTOSTREAM URL REWRITE VIA IMAGE SRC - from players/teams (slots don't use linkrule but cms param overrideLinkRulePhoto
    $(".rewritePhoto a.newsThumb").photoslideRewriteUrlFromImageSrc();
  });

} (jQuery, window));

;/* e  xclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

/*

DEPENDS:
/js/core/libraries/jquery-cookie/jquery.cookie-1.4.0.source.js

REPLACE:
\js\jquery\geo\jquery-geotargeting.source.js
\js\jquery\geo\jquery-geotargeting.lazy.js

LEGACY SUPPORT:
\code\Video\LiveVideo\LiveStreams\View\LiveStreamsBox.xslt (access to country without initialization - fixed)
\code\Mobile\Application\View\GetLink.xslt (to be fixed - not used)

*/
(function ($, win, undefined) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var trace = d3.Trace;
  
  // Default configuration properties.
  var defaults = {
      url: 'https://www.uefa.com/library/mobile/geo/check.html'
  };

  /*
  * The geotargeting singleton class.
  *
  */
  d3.Geotargeting = function (o) {


    /* ------------------------- */
    /* Variables */
    var _this = this,
        _opt = $.extend(true, {}, defaults, o || {}),  //options
        _proto = d3.Geotargeting.prototype,
        _isready = false,
        _country = '--',
        _TEST = false;



    /* ------------------------- */
    /* singleton logic */
    if (_proto._singletonInstance) {
      return _proto._singletonInstance;
    }

    _proto._singletonInstance = this;


    /* ------------------------- */
    /* Declaring private functions */
    var _initialize, _callback, _onReady;


    /* ------------------------- */
    //Public Functions
    this.country = '--';
    this.isValidUrl = 'N';

    this.whenReady = function (job) {
      //debugger;
      if ($.isFunction(job)) {
        if (_isready) {
          job();
        } else {
          _proto.jobs.push(job);
        }
      }

    };

    this.getCountry = function () {
      return _country.toString().toLowerCase();
    };

    this.validate = function () {
      trace("d3.Geotargeting - this.validate - TO BE IMPLEMENTED ");
      //TODO: validC.include(c) ?
      //      var _c = $.cookie('geo.CountryCode');
      //      if (_c !== undefined && c == null && c.length == 2 && c != '--' && validC.include(c))
      //        document.location.href = this.vdUrl;
      //      else
      //        document.location.href = this.cpUrl;
    };


    /* ------------------------- */
    //Private Functions

    _initialize = function () {

      var _c = $.cookie('geo.CountryCode');

      //trace(_c)

      //double check because old cookie libraries return null and not undefined
      if (_c === undefined || _c === null) {

        //var _url = win.location.hostname.indexOf('local') > -1 ? _opt.url.replace('html', 'htmx') : _opt.url;

        $.ajax({
          url: _opt.url,
          success: function (data) {
            if (data !== undefined && data.length === 2) {
              _callback(data, true);
            } else {

              $.ajax({
                url: _opt.url.replace('.html', '.htmx'),
                success: function (data) {
                  _callback(data, true);
                }
              });

            }
          }
        });

      } else {
        _callback(_c, false);
      }

    };

    _callback = function (originalResponse, save) {
      var t = originalResponse;
      if (t !== undefined && t.length === 2 && t !== '--') {

        //LEGACY SUPPORT
        _this.country = _country = t.toLowerCase();
        _this.isValidUrl = 'Y';

        if (!_TEST && save) {
          $.cookie('geo.CountryCode', _country); //TODO : 0
        }

      }

      _onReady();
    };

    _onReady = function () {

      while (_proto.jobs.length) {
        _proto.jobs.shift().call();
      }

      _isready = true;

    };

    //initialize singleton
    _initialize();
  };

  d3.Geotargeting.prototype.jobs = [];


  //LEGACY SUPPORT
  /*
  win.GeoTargeting = {
  initialize: function (callback) {
  trace('win.GeoTargeting.initialize - legacy support - TO BE REMOVED');
  var _geo = new d3.Geotargeting({});
  _geo.whenReady(callback);
  }
  };
  */

  //FORCE NEW
  //win.GeoTargeting.initialize();

} (jQuery, window));
;/*
* jprint: A simple print tool plugin.
* 
* Last modify : 15/12/2010
* Version : 0.1.6
* Released: Released in develop (24/11/2010). Released in training (10/12/2010)
* Changelog:
* - Created (v0.0.1)
* - updated code (changed requirements) (v0.0.2)
* - fixed methods.clickCallback (v0.0.3)
* - added methods.reverse (v0.0.3)
* - fixed "link" retrieval (based now on "media" attribute) v(0.0.4)
* - fixed click default behaviour (open a new window) v(0.0.5)
* - fixed IE7 window.open (and subsequently window.focus) (v0.0.6)
* - fixed window.open name parameter (to allow multiple page prints) (v0.0.7)
* - fixed hash append (v0.0.8)
* - fixed window.focus (v0.0.9)
* - added opts.switchElm (v0.1.0)
* - added opts.moveElm (could be set as a move-after or a move-before. default: move-after) (v0.1.1)
* - exposed methods.hasToken method (v0.1.2)
* - added meta[name=phototitle] injection (v0.1.3)
* - added opts.injectElm (v0.1.4)
*		- merged opts.moveElm, opts.switchElm, opts.injectElm into opts.elms property
*		- added methods.setInjectElms
* - changed elms.inject.what default value (v0.1.5)
* - fixed elms.switch.map[*] props for blog's post (v0.1.6)
*/
(function($) {
  var methods = {
    _addedKey: '___cssLinks',
    _elmsKey: '___elms',
    init: function($this, opts) {
      var _t = this;
      $this.bind('click', function(e) {
        e.preventDefault();
        if (opts.click.callback) {
          opts.click.callback(_t, opts);
          methods.clickCallback(_t, opts);
        }
        else methods.clickCallback(_t, opts);
      });
      jQuery.data(_t, _t._addedKey, $('link[media*="screen"]'));
      jQuery.data(_t, _t._elmsKey, opts.elms);
      if (methods.hasToken(opts)) $this.trigger('click');
      return $this;
    },
    clickCallback: function(mthis, opts) {

      var _gt = new Date().getTime();
      var _hasToken = methods.hasToken(opts);
      if (opts.click.newWindow && !_hasToken) {
        var _w = window.open(window.location.href + methods.setHash(opts), 'printpage' + _gt);
        _w.focus && _w.focus();
        return;
      }
      if (!_hasToken) window.location.href += methods.setHash(opts);
      mthis.setElms();
      if (opts.photoData) {
        var content = $(opts.photoData.title).attr('content');        
        if (content != '' && content != 'undefined' && content != null) {
          var _sel = opts.photoData.selector;
          if ($(_sel).length == 0) {
            var _attr = _sel.indexOf('.') == 0;
            var _html = '<span ' + (_attr ? 'class' : 'id') + '="' + _sel.substr(1) + '">' + content + '</span>';
            $(_html).appendTo(opts.photoData.parent);
          }
        }
      }
      if ($('.d3pg')) { $('.d3pg').replaceWith(''); }
      if ($('body')) { $('body').addClass('jprint'); }

      if (opts.firstTime == false) {
        jQuery.data(mthis, mthis._addedKey).each(function() {
          var _$this = $(this);
          if (_$this.attr('href').indexOf(opts.css.toSwitch) != -1) {
            _$this.attr('href', opts.css.toAdd + '?' + _gt);
          }
          else _$this.replaceWith('');

        });
        //set property
        opts.firstTime = true;
      }
      mthis.checkStatus(mthis, opts);
    },
    setHash: function(opts) {
      return opts.urlParam + (opts.appendTime ? '_' + new Date().getTime() : '');
    },
    _tm: null,
    checkStatus: function(mthis, opts) {
      _tm = setTimeout(function() {
        if (methods.hasToken(opts)) methods.checkStatus(mthis, opts);
        else methods.reverse(mthis, opts);
      }, 200);
    },
    reverse: function(mthis, opts) {
      var mthis = this;
      clearTimeout(_tm);
      if (methods.hasToken(opts)) return;
      mthis.setElms();
      jQuery.data(mthis, mthis._addedKey).each(function() {
        var _$this = $(this);
        if (_$this.attr('href').indexOf(opts.css.toAdd) != -1) {
          _$this.attr('href', opts.css.toSwitch + '?' + new Date().getTime());
        }
        else _$this.appendTo('head');
      });
    },
    hasToken: function(opts) {
      return (window.location.href.indexOf(opts.urlParam) != -1);
    },
    setElms: function() {
      var mthis = this;
      mthis.setSwitchElms('mapBefore', 'mapAfter');
      mthis.setMoveElms('from', 'toAfter');
      mthis.setInjectElms(mthis);
    },
    setSwitchElms: function(propFrom, propTo) {


      var mthis = this;
      var _elms = jQuery.data(mthis, mthis._elmsKey)['switch'];
      var i = _elms[propFrom].length;
      while (i--) {
        var _from = _elms[propFrom][i];
        var _to = _elms[propTo][i];
        if (_to) {
          var _$to = $(_to);
          if (_$to.length > 0) {
            var _toclass = "";
            if (_$to[0]) _toclass = _$to[0].className;
            var _tohtml = _$to.html();
            var _$from = $(_from);
            var _fromhtml = _$from.html();
            var _fromclass = "";
            if (_$from[0]) _fromclass = _$from[0].className;

            _$to.replaceWith('<div class="' + _fromclass + '">' + _fromhtml + '</div>');
            _$from.replaceWith('<div class="' + _toclass + '">' + _tohtml + '</div>');
          }
        }
      }
    },
    setMoveElms: function(propFrom, propTo) {
      var mthis = this;
      var _elms = jQuery.data(mthis, mthis._elmsKey).move;
      propFrom = mthis._setProp(propFrom, _elms);
      propTo = mthis._setProp(propTo, _elms);
      var i = _elms[propFrom].length;
      while (i--) {
        var _from = _elms[propFrom][i];
        var _to = _elms[propTo][i];
        if (_to) {
          var _$to = $(_to);
          var _$from = $(_from);
          if (!methods._setMovement(propTo, _$from, _$to)) { methods._setMovement(propFrom, _$to, _$from); }
        }
      }
    },
    setInjectElms: function() {
      if (opts.firstInject == false) {
        var mthis = this;
        var _elms = jQuery.data(mthis, mthis._elmsKey).inject;
        if (_elms.domCheck != '' && mthis._prevIsImage(_elms.domCheck)) return;
        var i = _elms.what.length;
        while (i--) {
          var _what = _elms.what[i];
          var _where = _elms.where[i];
          if (_where) {
            var $where = $(_where);
            $(_what).prependTo($where).show();
          }
        }
      }
      opts.firstInject = true;
    }
    ,
    _prevIsImage: function(o) {
      return (typeof $(o).prev().attr('src') !== 'undefined');
    },
    _setProp: function(prop, _elms) {
      if (prop == 'toAfter' && _elms['toAfter'].length == 0) prop = 'toBefore';
      if (prop == 'toBefore' && _elms['toBefore'].length == 0) prop = 'toAfter';
      return prop;
    },
    _setMovement: function(prop, from, to) {
      switch (prop) {
        case 'toAfter':
          to.after(from);
          break;
        case 'toBefore':
          to.before(from);
          break;
        default: return false;
      }
      return true;
    }
  };
  var defaults = {
    firstTime: false,
    firstInject: false,
    urlParam: '#jprint',
    css: { toSwitch: '/inc/css/main.css', toAdd: '/inc/css/printscreen.css' },
    click: { mode: 'auto', callback: null, newWindow: true },
    appendTime: false,
    elms:
		{ 'switch': { mapBefore: ['.postHead > .innerText > .postInfo > .fl'], mapAfter: ['.postHead .innerText .clear:eq(0)'] },
		  move: { from: ['#newsHeading > .byText.pubText', '.postHead .innerText .fl'], toAfter: ['.def_Newshead > .innerText > .newsTitle', '.def_Newshead > .innerText > .newsTitle'], toBefore: [] },
		  inject: { what: ['#hiddenHeader'], where: ['.innerText > h1.newsTitle:eq(0)'], domCheck: '.firstDiv.newsArt' }
		}, photoData: { title: 'meta[name="phototitle"]', parent: '.newsPhoto.rel', selector: '.phTitle' }
  };
  //,inject: { what: ['<img class="header" width="116" height="116" src="/imgml/elem/news_UefaLogoBlue.jpg"/>'], where: ['.innerText > h1.newsTitle'], domCheck: '.firstDiv.newsArt' }   

  var opts = {};
  $.fn.jPrint = function(options) {
    if (this.length == 0) return;
    opts = $.extend(defaults, options);
    if (opts.click.mode == 'inherit') opts.click.callback = this.attr('onclick');
    this.removeAttr('onclick');
    return methods.init(this, opts);
  };

  $.fn.jPrint.hasToken = function() {
    return methods.hasToken(opts);
  };
})(jQuery);
;/**
* jShare: A simple share tool plugin.
* 
* Last modify : 25/02/2011
* Version : 0.1.6
* Released: 20/08/2010 - Alberto Maghini
* Minor released: 28/02/2011 - Davide Aldrovandi
* Changelog:
* - fixed _init method
* - added jQuery.data to handle different element
* - fixed multiple "share" elements on page
* - fixed some bugs
* - fixed multiple share elements on page.
* - improved share-dialog template loading.
* - fixed double initialization.
* - added standalone functionalities (no json).
* - removed default callback (removed onclick popup).
*/
(function ($) {
  $.fn.jShare = function (options) {
    var defaults = {
      //###photostream
      type: 'news',
      cssClass: 'share-dialog',
      jsonPath: '/news/[padded-newsid]/json/newsid=[newsid],media.js',
      altPath: null,
      value: null,
      obj: [],
      dialogSelector: null,
      titleSelector: '#share-subject',
      templatePath: '/library/sendmail/_dialogtemplate.html'
    };
    var $document = $(document);
    var opts = $.extend(defaults, options);
    var c = __getDialog().css({ position: 'absolute', zIndex: 9999/*temporary css-rules*/, border: '4px solid #999', backgroundColor: '#FFF', display: 'none' });
    c.hide();
    var _w = $(window);
    this.close = function () {
      if (c.length == 0) return;
      c.find('input[type="text"]').each(function () {
        $(this).val('');
      });
      c.find('textarea').each(function () {
        $(this).val('');
      });
      c.find('select').each(function () {
        $(this).find('option[selected]').removeAttr('selected');
        $(this).find('options:eq(0)').attr('selected', 'selected');
      });
      c.hide();
    };

    var _defCallback = function ($this) {
      var _wh = _w.height();
      var _ww = _w.width();
      var _ch = c.outerHeight();
      var _cw = c.outerWidth();

      _ch = _ch <= 8 ? 404 : _ch;
      _cw = _cw <= 8 ? 350 : _ch;

      c.html(jQuery.data($document, '__dialogcontent_' + jQuery.data($this, 'value')))
			.css({ top: (_wh / 2) - (_ch / 2) + _w.scrollTop(), left: (_ww / 2) - (_cw / 2) }).show().find('.close').bind('click', function (e) {
			  e.preventDefault();
			  c.hide();
			  c.find('.close').unbind('click');
			});
    };

    this.init = function (paramsObj) {

      //###photostream
      if (paramsObj.type) {
        opts.type = paramsObj.type;
      }

      if (opts.type == 'video') {
        opts.href = paramsObj.href;
        opts.title = paramsObj.title;
      } else if (opts.type == 'photostream') {
        var _getIdImage = function (_src) {
          var regexS = "[0-9]*\_(s6).jpg";
          try {
            var regex = new RegExp(regexS);
            var _id = regex.exec(_src).shift().replace("_s6.jpg", "");
            return _id;
          } catch (e) {
            if (console && console.log) {
              console.log(e);
            }
          }
        };

        paramsObj.$this.bind("click", function () {
          var _current = $('.thumbs .current img');
          var _src = _current.attr("src");
          opts.value = _getIdImage(_src);
          return _init(paramsObj.$this);
        });
        return false;
      }
      //###/photostream

      if (paramsObj.value) opts.value = paramsObj.value;
      else if (paramsObj.href) opts.value = _rawInit(paramsObj.href);
      if (paramsObj.jsonPath && paramsObj.jsonPath != opts.jsonPath) opts.jsonPath = paramsObj.jsonPath;
      if (paramsObj.altPath) opts.altPath = paramsObj.altPath;

      return _init(paramsObj.$this);
    };

    function _rawInit(href) {
      var _s, _inews;
      var re = new RegExp('(newsid=|postid=)');

      if (re.test(href)) {
        if (href.indexOf('newsid=') > -1) {
          _s = 'newsid=';
          _inews = href.indexOf('newsid=');
        } else {
          _s = 'postid=';
          _inews = href.indexOf('postid=');
        }
      }

      var _inews = href.indexOf(_s);

      if (_inews > -1) {
        return href.substring(_inews + _s.length, href.indexOf('.htm')).replace(',print', '').replace('/_emailpopup', '');
      } else if (href.indexOf('nid=') > -1) {
        return href.substring(href.indexOf('#nid=') + 5);
      } else if (location.href.indexOf('uefarankings') > -1) {
        return 'uefarankings'
      } else {
        return null;
      }
    }

    function _init($this) {
      //c.load(opts.templatePath);
      $.ajax({
        url: opts.templatePath,
        success: function (response) {
          c.html(response)
          $this.each(function () {
            var _$this = $(this);
            var _value = opts.value ? opts.value : _rawInit(_$this.attr('href'));
            if (_value) {
              jQuery.data(_$this, 'value', _value);
              var _v = _getValue(_$this);

              if (opts.type == 'photostream') {//###photostream
                var _title = $('.wInfoTitle').text();
                opts.href = $('.type_permalink a').attr("href");
                opts.obj = {
                  "NewsId": opts.value,
                  "NewsTitle": _title,
                  "Subject": ''
                };
                $('#c_urln', c).val(opts.href);
                //console.log($('#c_urln',c))
                //console.log(_o)
                //console.log(opts.href)
                jQuery.data($document, '__dialogcontent_' + opts.value, __translateMarker(__restoreMarker(c.html())));
                _defCallback(_$this);

              } else {//###type news

                if (opts.type == 'video') {//###video player
                  opts.href = location.protocol + '//' + location.host + opts.href;
                  opts.obj = {
                    "NewsId": opts.value,
                    "NewsTitle": opts.title
                  };
                  $('#c_urln', c).val(opts.href);
                  jQuery.data($document, '__dialogcontent_' + opts.value, __translateMarker(__restoreMarker(c.html())));
                } else if (_value != 'uefarankings') {
                  _setAjaxCall(_$this, opts.jsonPath);
                } else {
                  opts.obj = {
                    "NewsId": "uefarankings",
                    "NewsTitle": __getSubject()
                  };
                  setjQueryData(opts.obj);
                }
                $this.removeAttr('onclick');
                /*
                if (!jQuery.data(_$this, 'callback')) {
                jQuery.data(_$this, 'callback', _$this.attr('onclick'));
                _$this.removeAttr('onclick');
                }
                */
                _$this.bind('click', function (e) {
                  e.preventDefault();

                  //if (jQuery.data(_$this, 'callback') && jQuery.data(_$this, '_useDefault')) jQuery.data(_$this, 'callback')();
                  //else 
                  _defCallback(_$this);
                });
              }

            }
          });
        }
      });
      return $this;
    }

    function _setAjaxCall($this, _p, onErrorStop) {
      $.ajax({
        type: 'GET',
        url: _translatePath($this, _p),
        dataType: 'json',
        error: function (http, status) {
          if (!onErrorStop && opts.altPath) _setAjaxCall($this, opts.altPath, true);
          else $this.hide(); //jQuery.data($this, '_useDefault', true);
        },
        success: function (data) {
          opts.obj = data;
          setjQueryData(data);
        }
      });
    }

    function setjQueryData(data) {
      if (!data.hasOwnProperty('NewsId')) return;
      jQuery.data($document, '__dialogcontent_' + data.NewsId, __translateMarker(__restoreMarker(c.html())));
    }

    function _translatePath($this, p) {
      var v = jQuery.data($this, 'value');
      var result = p;
      var re = new RegExp(/\[+([\w\-]*)\]/gim);
      var _m = re.exec(p);
      if (_m) {
        var _l = _m.length;
        var _mi;
        for (var i = _l - 1; i >= 0; i--) {
          _mi = _m[i];
          if (_mi.indexOf('padded') != -1 && _mi.indexOf('[') == -1) v = _setPadded(v);
          result = result.replace(_m[i - 1], v);
        }
        result = _translatePath($this, result);
      }
      return result;
    };

    function __translateMarker(html) {
      return __translate(html, /\[+([\w\-]*)\]/gim, ['*', '*']);
    }

    function __restoreMarker(html) {
      return __translate(html, /\*+([\w\-]*)\*/gim, ['[', ']']);
    }

    function __translate(html, rePattern, replaceArr) {
      var result = html;
      var re = new RegExp(rePattern);
      var _m = re.exec(html);
      if (_m && _m[0] && _m[0] !== '[]') {//jQuery 1.10 has an issue with this chunk of code. TODO: rewrite this plugin.
        var _l = _m.length;
        var _mi;
        for (var i = _l - 1; i >= 0; i--) {
          _mi = _m[i];
          var _r = opts.obj[_mi];
          if (!_r) _r = replaceArr[0] + _mi + replaceArr[1];
          result = result.replace(_m[i - 1], _r);
        }
        result = __translate(result, rePattern, replaceArr);
      }
      return result;
    }

    function _setPadded(p) {

      p = p.toString();

      if (p.length % 2 != 0) p = '0' + p;
      var _l = p.length;
      var result = '';
      for (var i = 0; i < _l - 1; i = i + 2) {
        result += p.substr(i, 2) + '/';
      }
      return result.substr(0, result.length - 1);
    };

    function __getDialog() {
      var _o = null;
      if (opts.dialogSelector) _o = _setClone($(opts.dialogSelector));
      else if (!(_o = __exists('#jshare-dialog'))) _o = _setContent();
      else _o = _setClone(_o);
      return _o;
    }

    function __getSubject() {
      var _s = '';

      if (opts.titleSelector && __exists(opts.titleSelector)) {
        _s = $(opts.titleSelector).val();
      }

      return _s;
    }

    function _setClone(_o, appendTo) {
      var r = _o;
      if (_o) {
        var _html = _o.html();
        _o = _o.html('');
        if (opts.dialogSelector.indexOf('#') == 0) document.getElementById(opts.dialogSelector.replace('#', '')).removeAttribute('id');
        r = _setContent().html(_html);
      }
      return r;
    }

    function _setContent(appendTo) {
      if (!appendTo) appendTo = 'body';
      return $('<div id="jshare-dialog" class="' + opts.cssClass + '"></div>').appendTo(appendTo);
    }
    function _getValue($this) {
      var _o = __exists(jQuery.data($this, 'value'));
      return _o != null ? _o.text() : jQuery.data($this, 'value');
    };

    function __exists(sel) {
      var _s = $(sel);
      return _s.length > 0 ? _s : null;
    };

    //return _init(this);
    return this;
  };
} (jQuery));
;/* exclude for JSLint parsing */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */
/*global window, jQuery */

/*
config lazyscripts
*/

(function ($, win) {

    'use strict';

    //Declare namespaces
    win.Deltatre = win.Deltatre || {};
    win.Deltatre.plugins = win.Deltatre.plugins || {};

    var _isMobile = ($('body').attr('id') === 'mobilesite');
    
    //TODO: move this map in a dedicated file (or better, write this map via vb/xml)
    //Declare scripts lazyloadable
    win.Deltatre.plugins.jsInjectionTable = {
        ovplayer: {
            js: '/inc/js/core/apps/videoplayer/inpage-embed.js',
            css: '/inc/styles/' + (_isMobile ? 'mobilesite/' : '/') + 'videoplayer/inpage.embed.css'
        },
        ovplayernewsembed: {
            js: '/inc/js/core/apps/videoplayer/news-embed.js'
          },
        audioplayernewsembed: {
            js: '/inc/js/core/apps/audioplayer/audio-embed.js'
        },
        video: {
            js: '/inc/js/core/apps/video/main.js',
            css: '/inc/css/video/player.css'
        },
        tooltip: {
            js: '/inc/js/core/plugins/tooltip.js'
        },
        tablesorter: {
            js: '/inc/js/core/plugins/tablesorter.js'
        },
        ajaxform: {
            js: '/inc/js/core/plugins/ajaxform.js'
        },
        captcha: {
            js: '/inc/js/core/plugins/captcha.js'
        },
        oftabs: {
            js: '/inc/js/core/apps/oftabs/oftabs.js'
        },
        localtime: {
            js: '/inc/js/core/plugins/localtime.js'
        },
        lslocaltime: {
            js: '/inc/js/core/apps/livescores/lslocaltime.js'
        },
        pluckNumRates: {
            js: '/inc/js/core/apps/pluck/numrates.js'
        },
        pluckNumComments: {
            js: '/inc/js/core/apps/pluck/numcomments.js'
        },
        contactus: {
            js: '/inc/js/core/plugins/contactus.js'
        }
    };


} (jQuery, window));

;/* exclude for JSLint parsing */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */
/*global window, jQuery */

/*
FRAMEWORK d3 2013
lazyscripts system
*/

(function ($, win) {

  'use strict';

  //shortcuts
  var d3 = win.Deltatre;
  var util = d3.util;
  //var trace = d3.Trace;
  //UEFA TODO : var track = OmniTracker.action;

  d3.LazyScript = function (plugin, map) {

    /* ------------------------- */
    /* Variables */
    var _isready = false,
        _ref = d3.LazyScript.prototype.instances[plugin],
        _proto,
        _obj;

    /* ------------------------- */
    /* Prototype creation        */
    if (!_ref) {
      _obj = d3.LazyScript.prototype.instances[plugin] = function () { return undefined; };
      _proto = _obj.prototype;
    } else {
      _proto = _ref.prototype;
    }


    //trace(plugin, d3.plugins.jsInjectionTable, _obj, _proto);

    /* ------------------------- */
    /* singleton logic */
    if (_proto._singletonInstance) {
      return _proto._singletonInstance;
    }

    _proto._singletonInstance = this;
    _proto.jobs = [];

    /* ------------------------- */
    /* Declaring private functions */
    var _initialize, _onReady;


    /* ------------------------- */
    //Public Functions
    this.whenReady = function (job) {
      //debugger;
      if ($.isFunction(job)) {
        if (_isready) {
          job();
        } else {
          _proto.jobs.push(job);
        }
      }

    };

    /* ------------------------- */
    //Private Functions

    _initialize = function () {

      if (map.css) {
        util.appendStyle(map.css, 'd3.css.' + plugin);
      }

      util.appendScript(map.js || map, _onReady, 'd3.js.' + plugin);

    };

    _onReady = function () {

      while (_proto.jobs.length) {
        _proto.jobs.shift().call();
      }

      _isready = true;

    };

    //initialize singleton
    _initialize();

  };

  d3.LazyScript.prototype.instances = {};

} (jQuery, window));

;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

/*
FRAMEWORK d3 2013
selector used by the system:

d3-plugin : plugin
img.js-lazy, .d3-plugin-lazy : lazy images/plugin


TEST: gold - open this page with filezilla:
/uefachampionsleague/news/newsid=2012601.html?isdebug
replace last ssi components.js with
<script type='text/javascript' src='http://localhost:8001/inc/js/core/base/components.js?20131120092831' > </script>
*/

(function ($, win) {

  'use strict';

  //Declare namespaces
  win.Deltatre = win.Deltatre || {};
  win.Deltatre.plugins = win.Deltatre.plugins || {};

  //shortcuts
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var trace = d3.Trace;
  //var util = d3.util;
  //UEFA TODO : var track = OmniTracker.action;


  //legacy managment
  var legacy = d3.Legacy ? new d3.Legacy() : false;

  //d3Plugin launch function
  //pn = plugin name
  $.fn.d3Plugin = function (data, pn) {
    var o = data.options || {};

    if (d3.IS_DEBUG === true && Object.prototype.toString.call(o) === '[object String]') {
      trace('Options parsing error - ' + pn + ' - ', o, this);
    }

    return this.each(function () {

      var $this = $(this);

      if (!p3[pn] && p3.generic && !p3.generic.prototype.plugins[pn]) {
        trace(pn + ' does not exist');
      }

      try {
        //if (typeof $this.data(pn) === 'undefined') {
        var _check = $this.data(pn);
        if (!_check) {

          var p;

          if (p3[pn]) {
            p = new p3[pn]($this, o);
          } else if (p3.generic && p3.generic.prototype.plugins[pn]) {
            p = new p3.generic(pn, $this, o);
          }

          if (data.api || p.api) {
            //store entire object
            $this.data(pn, p);
          } else {
            //store boolean in order to avoid double instance call
            $this.data(pn, true);
          }
          p.init();
        } else {
          trace('plugin yet launched', $this, o, pn);
        }
      } catch (e) {
        trace(e);
        trace('plugin function error', $this, o, pn);
      }

    });
  };

  /*
  * The core engine.
  *
  */
  d3.core = function () {

    /* ------------------------- */
    /* Variables */
    var _this = this;

    /* ------------------------- */
    /* Declaring private functions */
    var existPlugin,
    injectPlugin,
		launchPlugin,
		launchParsers;


    /* ------------------------- */
    //Public Functions


    //Launch d3 plugins attached to selected elements
    //$elements = elements to look for plugins
    this.launchPlugin = function ($el) {

      var plugin = $el.data('plugin');

      //check if exist
      //if (typeof plugin === 'undefined') {
      if (!plugin) {
        trace('can not find data-plugin for element');
        trace($el);
        return;
      }

      launchPlugin($el, plugin);

    };


    //Launch d3 plugins attached to selected elements
    //$elements = elements to look for plugins
    this.launchPlugins = function ($elements, sel) {
      var plugin;

      //trace($elements, sel);

      if (!sel) {
        sel = '.d3-plugin';
      }

      //LEGACY Main - launch only with default selector and when the $elements === document
      if (legacy && $elements === document && sel === '.d3-plugin') {
        legacy.parse($($elements));
      }

      //convert to jquery for sure
      $elements = $($elements);

      //up one level if $elements is a plugin
      if ($elements.is(sel)) {
        $elements = $elements.parent();
      }
      
      var $list = $elements.find(sel);
      var ii;
      var nn = $list.length;
      var $el;

      //trace($list, nn);

      for (ii = 0; ii < nn; ii++) {
        $el = $list.eq(ii);
        plugin = $el.data('plugin');

        //trace($el, plugin);

        //check if exist
        //if (typeof plugin === 'undefined') {
        if (!plugin) {
          trace('can not find data-plugin for element');
          trace($el);
          continue;
          //return;
        }

        if (!existPlugin(plugin)) {
          //try to inject plugin code
          if (d3.LazyScript) {
            injectPlugin($el, plugin);
          } else {
            trace('d3.LazyScript missing - plugin not exist:', $el, plugin);
          }
        }
        else {
          //launch
          launchPlugin($el, plugin);
        }
      }



      //parsers
      //attention - here ther isn't check of double instance
      //TODO: consider implement more safe code or remove concept of parsers
      launchParsers($elements);

      //lazy elements are launched by generic parser
      //\js\core\parsers\generic.source.js
      //$("img.js-lazy, .d3-lazy-plugin", $elements).lazyload();
      //$(win).trigger("scroll");

    };

    //alias of launchPlugins
    this.parse = this.launchPlugins;


    //load a script asynchronously
    //TODO : this.loadScript


    this.parentPlugin = function (el, plugin) {
      return $(el).closest('[data-plugin="' + plugin + '"]').data(plugin);
    };

    /* ------------------------- */
    //Private Functions
    //pn = plugin name
    launchPlugin = function ($elements, pn) {
      var $el, data;

      //for each elements found
      $elements.each(function (i, el) {
        $el = $(el);
        data = $el.data(); //data
        $el.d3Plugin(data, pn);
      });
    };

    //try to load the plugin source if plugin not available
    injectPlugin = function ($el, plugin) {


      //trace('injecting plugin - ', p3.jsInjectionTable[plugin]);
      var _lazy = $el.data('script') || (p3.jsInjectionTable && p3.jsInjectionTable[plugin]);

      if (_lazy) {

        var _loader = new d3.LazyScript(plugin, _lazy);
        _loader.whenReady(function () {
          launchPlugin($el, plugin);
        });

      } else {

        trace('can not find plugin for element', plugin);
        trace($el);
      }
      //TODO: d3.injector.injectPlugin($el, plugin);
    };

    existPlugin = function (pn) {
      return !!p3[pn] || (p3.generic && !!p3.generic.prototype.plugins[pn]);
    };

    launchParsers = function ($elements) {
      //trace(_this.parsers);
      $.each(_this.parsers, function (k, v) {
        try {
          v($elements);
        } catch (e) {
          trace('error launching parser', k);
          trace(e);
          return true;
        }
      });
    };



  };



  //PARSERS
  $.extend(d3.core.prototype, {
    parsers: {}
  });

  //Create a single instance and init
  var core = new d3.core();

  d3.core.getInstance = function () {
    //Return singleton instance
    return core;
  };



} (jQuery, window));

;/* exclude for JSLint parsing */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */
/*global window, jQuery */

(function ($, win, undefined) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  //var trace = d3.Trace;
  //var core = d3.core.getInstance();

  // Default configuration properties.
  var defaults = {
    selector: '.js-target, .hover',
    method: 'hover'  //hover|hoverIntent
  };

  /*
  * The skeleton object.
  *
  */
  p3.toggle = function (e, o) {

    /* ------------------------- */
    /* Variables */
    //var _this = this;
    var _opt = $.extend(true, {}, defaults, o || {});  //options
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements

    /* ------------------------- */
    /* Declaring private functions */

    /* ------------------------- */
    //Public Functions
    this.init = function () {
      $de.target = $dom.find(_opt.selector);
      if ($de.target.length === 0) {
        $de.target = $dom.contents();
      }

      $dom[_opt.method](
      function () {
        $de.target.show();
      },
	    function () {
	      $de.target.hide();
	    }, _opt);
    };


    /* ------------------------- */
    //Private Functions


  };


} (jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

(function ($, win, undefined) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var core = d3.core.getInstance();
  //var trace = d3.Trace;

  // Default configuration properties.
  var defaults = {
    handler: false,
    event: 'event',
    plugin: false,
    via: 'lazybyevent'
  };

  /*
  * The lazybyevent object.
  * Launch plugin passed via options at the first trigger of the event specified via option
  * Example: the search form launch the plugin at the first focus (the plugin is lazyscript type). 
  * In this way all the libraries of the suggest component it's possibile to separate from components.js 
  * and load it only when the user enter for the first time in the form
  */
  p3.lazybyevent = function (e, o) {

    /* ------------------------- */
    /* Variables */
    //var _this = this;
    var _opt = $.extend(true, {}, defaults, o || {});  //options
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements

    /* ------------------------- */
    /* Declaring private functions */
    var _launch;

    /* ------------------------- */
    //Public Functions
    this.init = function () {

      $de.handler = _opt.handler ? $dom.find(_opt.handler) : $dom;

      if (_opt.event === 'hoverIntent' && ($.fn.hoverIntent === undefined)) {
        _opt.event = 'mouseenter';
      }


      if (_opt.event === 'hoverIntent') {

        $de.handler.hoverIntent({
          over: function () {
            _launch();
          },
          interval: 250
        });

      } else {

        $de.handler.one(_opt.event, function () {

          _launch();

        });

      }


    };


    /* ------------------------- */
    //Private Functions



    _launch = function () {
      //d3.Trace('lazybyevent- in');


      //pass to the plugin activated the name of this plugin. 
      //in some case this type of activation is not transparent 
      //for example when the event that activate the plugin is used by plugin for something
      //this issue is visibile in \js\core\apps\dropdownhp\dropdownhp.source.js
      //the hover trigger the launch the plugin and the json download
      //the first hover is not readed by plugin.

      $dom
      .data('options', _opt)
      .data('plugin', _opt.plugin);

      if ($.metadata) {

        $dom.metadata('data-options', _opt);

        $dom.attr('data-plugin', _opt.plugin);

      }

      core.parse($dom);
    };

  };


} (jQuery, window));
;/* exclude for JSLint parsing */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */
/*global window, jQuery, location, SEARCH_HOSTNAME */

(function ($, win, undefined) {

  'use strict';

  win.Deltatre = win.Deltatre || {};
  win.Deltatre.plugins = win.Deltatre.plugins || {};

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var trace = d3.Trace;
  //var core = d3.core.getInstance();

  // Default configuration properties.
  //var defaults = {};

  /*
  * The skeleton object.
  *
  */
  p3.search = function (e, o) {

    /* ------------------------- */
    /* Variables */
    //var _this = this;
    //var _opt = $.extend(true, {}, defaults, o || {});  //options
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements

    $(".dropdown.nav-search").on("shown.bs.dropdown", function (event) {
      $(this).find('#hse').focus();
    })

    /* ------------------------- */
    /* Declaring private functions */

    /* ------------------------- */
    //Public Functions
    this.init = function () {

      $de.input = $dom.find('.js-input');
      $de.seVal = $dom.find('.js-label');

      $dom.submit(function (e) {
        var q = $de.input.val();

        var searchost = location.host;
        var isthird = true;
        var strlang = location.pathname;
        var pagelang = strlang.split("/")[1];
        var langcodes = new Array('www', 'en', 'fr', 'es', 'pt', 'it', 'ru', 'de', 'jp');
        for (i = 0; i < langcodes.length - 1; i++) {
          if (searchost == langcodes[i] + '.uefa.com') {
            isthird = false;
            break;
          }
        }
        if (pagelang != 'www' && pagelang != 'en' && pagelang != 'fr' && pagelang != 'es' && pagelang != 'pt' && pagelang != 'it' && pagelang != 'ru' && pagelang != 'de' && pagelang != 'jp' || pagelang == '') {
          pagelang = 'en';
        }

        if (isthird) {
          var SEARCH_HOSTNAME = pagelang + '.uefa.com'
        } else {
          var SEARCH_HOSTNAME = searchost;
        }

        if (q.toLowerCase() !== $de.seVal.text() && q !== '') {
          location.href = 'http:/' + '/' + SEARCH_HOSTNAME + '/search/index.html#' + q;
        }
        e.preventDefault();
      });

      /* handle focus event of input text field - empty the text if NOT the default */
      $de.input.focus(function () {
        if ($(this).val().toLowerCase() === $de.seVal.text().toLowerCase()) {
          $(this).val('');
        }
      });

      /* handle blur event of input text field - re-fill with the default text */
      //$de.input.blur(function () {
      //  if ($(this).val() === '') {
      //    $(this).val($de.seVal.text()).css('text-transform', 'capitalize');
      //  }
      //});

    };


    /* ------------------------- */
    //Private Functions


  };


  //FIX 3rd parties
  if (location.pathname === '/search/index.html' && location.search.length > 0) {
    location.href = location.href + '#' + location.search.replace("?q=", "");
  }


}(jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

(function ($, win) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  //var trace = d3.Trace;
  //var core = d3.core.getInstance();



  // Default configuration properties.
  var defaults = {
    timeout: 60000,
    isthirdy: 'Y',
    url: '/livecommon/_matchesminute_jsonp.json',
    domain: 'http://www.uefa.com'
  };

  /*
  * The jsonplive object.
  *
  */
  p3.jsonplive = function (e, o) {

    /* ------------------------- */
    /* Variables */
    var _this = this;
    var _opt = $.extend(true, {}, defaults, o || {});  //options
    var $dom = e; //the jquery element we are working with
    //var $de = {}; //dom elements
    var _enabledCup = [1, 3, 5, 9, 13, 14, 17, 18, 22, 23, 24, 25, 27, 28, 38, 39, 101, 2008];
                        //1026, 1027, 1028, 1031, 1032, 1035, 1038, 1039, 1042, 1046, 1048, 1049, 1050, 1053, 1054, 1055, 1056, 1062, 1069];
    var _live;

    /* ------------------------- */
    /* Declaring private functions */
    var _doPoll;
    /* ------------------------- */
    //Public Functions
    this.init = function () {

      //retrocompatibility
      d3.Uefacom = d3.Uefacom || {};
      d3.Uefacom.Livepolling = d3.Uefacom.Livepolling || {};

      //jsonp callback function
      d3.Uefacom.Livepolling.checklive = _this.checklive;


      if (_opt.isthirdy === 'Y') {
        _opt.url = _opt.domain + _opt.url;
      }

      _doPoll();


    };

    this.checklive = function (json) {

      //trace("checklive", json, json.m);

      _live = false;

      $.each(json.m, function (i, v) {

        if (($.inArray(v.cup, _enabledCup) > -1 && (v.s === "3"))) {
          _live = true;
          return false;
        }
      });

      //trace("checklive", _live, $dom);
      $dom.toggleClass('is-live', _live);

      //export data in global object (protype of the plugin)
      window.Deltatre.plugins.jsonplive.prototype.data = json;
      $(document).trigger('jsonplive.ondata');
    };


    /* ------------------------- */
    //Private Functions
    _doPoll = function () {

      //var v = '?v=' + new Date().getTime();

      $.ajax({
        type: 'GET',
        url: _opt.url,
        //url: '/livecommon/_matchesminute_jsonp.json',
        dataType: 'jsonp'
      });
      win.setTimeout(_doPoll, _opt.timeout);
    };

  };


} (jQuery, window));
;/* exclude for JSLint parsing */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */
/*global window, jQuery */

/* 
Depends on $.hoverIntent
*/

(function ($, win, undefined) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var trace = d3.Trace;
  //var core = d3.core.getInstance();

  // Default configuration properties.
  var defaults = {
    url: undefined,
    thirdparty: false
  };

  /*
  * The skeleton object.
  *
  */
  p3.dropdownhp = function (e, o) {

    /* ------------------------- */
    /* Variables */
    //var _this = this;
    var _opt = $.extend(true, {}, defaults, o || {});  //options
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements

    /* ------------------------- */
    /* Declaring private functions */
    var _ondone, _onfail, _bind;
    /* ------------------------- */
    //Public Functions
    this.init = function () {

      if (_opt.url) {

        $de.target = $dom.find('.js-target');

        //thirdparty don't use json/jsonp
        if (_opt.thirdparty) {

          _ondone();

        } else {

          if ($.metadata) {
            $.getJSON(_opt.url, _ondone);
          } else {
            $.getJSON(_opt.url)
            .done(_ondone)
            .fail(_onfail);
          }

        }



        _bind();
      }

    };


    /* ------------------------- */
    //Private Functions
    _bind = function () {
      var _method = $.fn.hoverIntent === undefined ? 'hover' : 'hoverIntent';

      if (_method === 'hover') {
        $dom[_method](function () {
          $de.target.show();
        }, function () {
          $de.target.hide();
        });
      } else {
        $dom[_method]({
          over: function () {
            $de.target.show();
          },
          out: function () {
            $de.target.hide();
          },
          sensitivity: 7,
          interval: 250,
          timeout: 200
        });
      }


    };

    _ondone = function (data) {
      //trace(data);

      $de.target = $de.target.show();
      if (data && data.html) {
        $de.target.append(data.html);
      }

      //then bind hoverintent on 
      $de.target = $de.target.children();

      //if the plugin is launched via lazybyevent (via mouseenter)
      //the first mouseenter is not triggered
      if (_opt.via && _opt.via === 'lazybyevent') {
        if ($dom.is(":hover")) {
          $de.target.show();
          $dom.one("mouseleave", function () {
            $de.target.hide();
          });
        }
      }

    };

    _onfail = function (jqxhr, textStatus, error) {
      var err = textStatus + ", " + error;
      trace("Request Failed: " + err);
    };

  };

  //this selector .js-orig-hover handle the original toggle via css
  //remove as soon as possibile in order to manage hover via plugin
  $(document).ready(function () {
    $('.d3cmsHeader .js-orig-hover').removeClass('js-orig-hover');
  });

} (jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

(function ($, win) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var trace = d3.Trace;
  //var core = d3.core.getInstance();

  var defaults = {
    //register here generic name of parsers
    parsers: {
      //$.fn.plugin : '.selector'
      d3fb: {
        selector: '.fb-button, .fblike, .fb-btn',
        options: {}
      },
      d3twitter: {
        selector: '.twitter-share',
        options: {}
      },
      lazyload: {
        selector: 'img.js-lazy,iframe.js-lazy, .d3-plugin-lazy',
        options: {}
      },
      hoverSlide: {
        selector: '.js-hoverslide'
      }
      //      , fblazy: {
      //        selector: '.fblazy-wrap'
      //      }
    }
  };

  /* GENERIC PARSER - used instead of d3-plugin when elements are many and options doesn't change never */
  //TODO: when number of these parser will be greater implement a sort of logic for limit the $ calls by page/sections
  d3.core.prototype.parsers.generic = function ($dom) {
    $.each(defaults.parsers, function (plugin, obj) {
      //trace($(obj.selector), plugin,$.fn[plugin]);
      if ($.fn[plugin]) {
        $(obj.selector, $dom)[plugin](obj.options);
      } else {
        trace('generic parser : jquery plugin not defined.', plugin);
      }
    });
  };


} (jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

(function($, win) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  //var trace = d3.Trace;
  //var core = d3.core.getInstance();

  // Default configuration properties.
  //var defaults = {};

  /*
  * The polling object.
  *
  */
  p3.generic = function(plugin, e, o) {

    /* ------------------------- */
    /* Variables */
    //var _this = this;
    //var _opt = $.extend(true, {}, defaults, o || {});  //options	
    var $dom = e; //the jquery element we are working with
    //var $de = {}; //dom elements

    /* ------------------------- */
    /* Declaring private functions */


    /* ------------------------- */
    //Public Functions
    this.init = function() {
      return $dom[this.plugins[plugin]](o);
    };


    /* ------------------------- */
    //Private Functions


  };

  p3.generic.prototype.plugins = {
    'facebook': 'd3fb',
    'twitter': 'd3twitter',
    'js-fblazy' : 'fblazy'
  };


} (jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true */

(function ($, win) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var trace = d3.Trace;
  var core = d3.core.getInstance();

  // Default configuration properties.
  var defaults = {
    islegacy: false, //uefaLive option
    timestamp: null,
    timeout: null,
    urlcheck: null,
    urlget: null,
    callback: function (html, $dom) {     //callback dopo aver effettuato l'aggiornamento

      var $html = $(html);

      if ($html.attr('data-plugin') === 'Live') {//data('plugin') - jquery 1.3.2 compatiblity
        var $parent = $dom.parent();
        //trace($parent);
        $parent.html($html);
        core.parse($html.parent());
      } else {
        $dom.html($html);
        core.parse($html);
      }

    }
  };

  /*
  * The polling object.
  *
  */
  p3.Live = function (e, o) {

    /* ------------------------- */
    /* Variables */
    var _this = this;
    var _opt = $.extend(true, {}, defaults, o || {});  //options
    var $dom = e; //the jquery element we are working with
    //var $de = {}; //dom elements

    /* ------------------------- */
    /* Declaring private functions */

    /* ------------------------- */
    //Public Functions

    this.init = function () {

      if (_opt.timeout !== undefined && _opt.urlget !== undefined) {
        $dom.uefaLive(_opt);
      }

    };

    /* ------------------------- */
    //Private Functions


  };


} (jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

/*
DEPENDS on 

- jQuery UI 1.9.2:
jquery.ui.core.js
jquery.ui.widget.js
jquery.ui.effect.js (probably)
jquery.ui.tabs.js

- replace old implementation:
C:\TFS\uefacom\trunk\WebApp\uefa.com\HTMLTemplate.source\js\jquery\jquery.tabs.add.source.js

- VIEWS:

1) \code\Templates\Layouts\TabsFromXml\TabsFromXml.xslt (3 test)

TEST: 
/library/catalog/tabs/_index_r1.html

2) 

TEST: 
/library/catalog/tabs/_index_r1.html


\code\Templates\Layouts\Tabs\TabsAjax.xslt
\code\Templates\Layouts\Tabs\View\NewHp.xslt

TEST:
/library/catalog/tabs/_index_r2.html

\code\Templates\Layouts\Tabs\TabsAjaxSquad.xslt

TEST:
/library/catalog/tabs/_index_r3.html

\code\Templates\Layouts\Tabs\View\NewHpEuro.xslt 

TEST: TODO: check height issues when remote tab loading
/library/catalog/tabs/_index_r5.html

TODO TEST:

\code\Templates\Layouts\Tabs\VideoReplayTabs.xslt (not used)
\code\Templates\Layouts\Tabs\VideoReplay.xslt (not used)
\code\Templates\Layouts\Tabs\TabsAjaxVertical.xslt (not used - DELETED)

\code\WhiteLabel\TraingGround\TabsAjax\View\TabsAjax.xslt (TODO)

TODO: datagrid stats + history ucl drawcentre

\code\FootballStats\General\DataGrid.xslt													
\code\History\Tabs\View\Polls.xslt
\code\History\Tabs\View\Video.xslt
\code\DrawCentre\Template\Tabs.xslt

*/


(function ($, win) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var trace = d3.Trace;
  var core = d3.core.getInstance();

  // Default configuration properties.
  var defaults = {
    parseHash: false,
    insDeepLink: false,
    //tabs options
    cache: true,
    select: function (event, ui) {
      var url = $(ui.tab).attr('rel');
      if (url && url.length > 0) {
        win.location.href = url;
      }
    }

  };


  /*
  * The Tabs object.
  *
  */
  p3.tabs = function (e, o) {

    /* ------------------------- */
    /* Variables */
    //var _this = this;
    var _opt = $.extend(true, {}, defaults, o || {});  //options	
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements
    var _active;

    /* ------------------------- */
    /* Declaring private functions */
    var  _parseHash, _options, _selected, _insDeepLink;

    /* ------------------------- */
    //Public Functions
    this.init = function () {

      //TODO : selector of the menu must be more clear
      $de.headers = $dom.find('.menu li:has(a)');
      //trace($de.headers);
      $de.selected = $dom.find('li.selected');

      //if tabs > 1 don't init UI tab code 
      //es: mainnewstab with only 1 tab
      //-> url : /worldcup/index.html
      if ($de.headers.length > 1) {


        //legacy code
        _parseHash();

        //set callbacks
        _options();

        //set selected
        _selected();


        if ($.metadata) {
          $dom.tabs("destroy").removeData('tabs');
        }

        //init 
        $dom.tabs(_opt);

        //select by url
        _insDeepLink();


      } else {
        if ($de.headers.length > 0) {
          $de.headers.eq(0).addClass('selected ui-tabs-selected ui-state-active');
        }
      }

    };

    
    /* ------------------------- */
    //Private Functions

    //Very stupid functionality - simil to hash. try to refactory these functions
    //Don't seems to work. UI Tabs select all instances in a page
    _insDeepLink = function () {
      if (_opt.insDeepLink) {
        trace('Tabs insDeepLink - func to be removed');
        var _params = win.location.search.indexOf('selected') > -1 ? win.location.search : win.location.hash, i, _temp, _sel;
        var _allParams = [], _splitparams = _params.split("&");
        for (i = 0; i > _splitparams.length; i++) {
          _temp = _splitparams[i].split("=");
          _allParams[_temp[0]] = _temp[1];
        }
        if (_allParams.selected) {
          _sel = parseInt(_allParams.selected, 10) - 1;
          if (_sel > 1) {
            $dom.tabs('select', _sel);
          }
        }
      }
    };

    


    //set callback options 
    _options = function () {
      //launch plugins after load of remote tabs
      _opt.load = function (event, ui) {
        //trace('Tabs - Ajax - parse plugins', $(ui.panel));
        core.parse($(ui.panel));
      };

      _opt.show = function (event, ui) {

        //legacy inline function support 
        //to be removed
        if (win.fnTabsAfterShow) {
          trace('Tabs win.fnTabsAfterShow - func to be removed');
          win.fnTabsAfterShow(event, ui);
        }

       
      };
    };

    //selected logic based on hash
    _parseHash = function () {
      //TODO: test this code - don't works
      if (_opt.parseHash || $dom.hasClass('parseHash')) {
        trace('Tabs parseHash - func to be removed');
        var _id = win.location.hash.replace("#", "");
        var _channel = '#ui-tabs-' + _id;
        var $sel = $dom.find(_channel);
        //trace('parseHash', _id, $sel);
        if ($sel.length > 0) {
          $de.selected.removeClass("selected");
          $sel.addClass("selected");
        }
      }
    };


    //selected logic
    _selected = function () {
      //set selected
      _active = $de.headers.index($de.selected);
      //trace('Selected', _active, $de.selected);
      if (_active > -1) {
        _opt.selected = _active;
      }
    };

   

  };

} (jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

/*
DEPENDS on 

- jQuery UI 1.9.2:
jquery.ui.core.js
jquery.ui.widget.js
jquery.ui.effect.js (probably)
jquery.ui.accordion.js

VIEWS:
\code\FootballData\Matches\Calendar\View\AccordionCalendarPK.xslt
\code\FootballData\Matches\Calendar\View\AccordionCalendarByRound.xslt
\code\FootballData\Matches\Calendar\View\AccordionCalendar.xslt

TEST: /library/catalog/accordion/_index_r1.html

\code\FootballData\Players\PlayerAccordion\View\Accordionplayers.xslt
\code\Templates\Layouts\HpMatches\AccordionHpMatches.xslt
\code\Editorial\Blogs\View\BlogsArchive.xslt

TEST: /library/catalog/accordion/_index_r2.html

\code\FootballData\Matches\MatchesPerRound\View\MatchesPerRoundAndMD.xslt
\code\FootballData\Team\TeamListPerRound\View\TeamByRoundAccordion.xslt
\code\FootballData\Statistics\Accordion\View\AccordionStatistic.xslt

TEST: /library/catalog/accordion/_index_r4.html

\code\FootballData\Team\TeamSquad\View\AccordionTeamSquad.xslt

TEST: /library/catalog/accordion/_index_r5.html

\code\FootballData\Team\TeamSquad\View\AccordionSquad.xslt

TEST: /library/catalog/accordion/_index_r6.html

*/

(function ($, win) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var trace = d3.Trace;
  //var core = d3.core.getInstance();

  // Default configuration properties.
  var defaults = {
    autoHeight: false,
    header: 'h3, p.accHeader',
    fillSpace: false
    //heightStyle: 'content'
  };

  /*
  * The polling object.
  *
  */
  p3.accordion = function (e, o) {

    /* ------------------------- */
    /* Variables */
    var _this = this;
    var _opt = $.extend(true, {}, defaults, o || {});  //options	
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements

    /* ------------------------- */
    /* Declaring private functions */


    /* ------------------------- */
    //Public Functions
    this.init = function () {


      $de.headers = $(_opt.header, $dom);
      $de.selected = $de.headers.filter('.selected');

      //legacy code - probably instead of use of hash it could be pass href via data
      if (_opt.ajax) {
        $de.headers.each(function (i) {//TEMP h3
          var _target = $(this).next();
          var _handler = $(this);
          $('a', this).each(function () {
            var _href = this.hash.replace("#", "").replace(/\|/g, "/");
            this.href = "#";
            $(_handler).one("click", function () {
              $.get(_href, function (data) {
                _target.html(data);
              });
            });
          });
        });
      }

      if ($de.selected.length > 0) {
        _opt.active = $de.headers.index($de.selected);
      }


      //jquery UI 1.7.2 + /uefachampionsleague/season=2014/matches/round=2000479/match=2011826/postmatch/photos/index.html
      //matchlist live + accordion
      if ($.metadata) {
        $dom.accordion("destroy").removeData('accordion');
      } else {

        //#REGION - TODO - REWRITE CSS
        _opt.create = function (event, ui) {
          $(event.target).children('div').addClass('ui-ac-content');
        };
        //#REGION - TODO - REWRITE CSS
      }


      //launch UI plugin
      $dom.accordion(_opt);

      if ($.metadata) {
        $dom.bind("accordionchange", function (event, ui) {
          ui.newContent.prevObject.css("overflow", "auto"); //IE BUG
        });
      }


    };


    /* ------------------------- */
    //Private Functions


  };


} (jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

/*
DEPENDS on 

- jQuery
- /js/core/libraries/jquery-jcarousel/jquery.jcarousel.0.2.9.js

TODO : _opt.wrap = 'circular'

replace old istances:

1)  /js/jquery/jcarousel-0.2.8.p1/jquery.jcarousel.adduclhp.source.js
  
VIEWS:
\code\Editorial\NewsList\View\VNewsListHorizontalSlide.xslt
\code\FootballData\Matches\Calendar\View\CarouselCalendar.xslt

2)  /js/ureader/videoslide.js

VIEWS:
\code\Editorial\NewsList\View\UreaderNewsListVideo_Slide.xslt

3) \js\jquery\newscarousel\jquery.jcarousel.news.source.js

VIEWS:
\code\Editorial\NewsCarousel\View\PromoCarousel.xslt

4) \js\jquery\jquery.jcarousel.add.source.js

VIEWS:
\code\Editorial\NewsList\View\NewsList_Slide.xslt
\code\Editorial\NewsList\View\NewsTickerMA_HP.xslt
\code\Editorial\Article\View\Photo_SlideRelated.xslt
\code\Elements\Alphabet\View\LetterListTitle.xslt
\code\Elements\Alphabet\View\LetterListAnchor.xslt
\code\Elements\Alphabet\View\LetterList.xslt
\code\Elements\Group\View\GroupListStandings.xslt
\code\Elements\Group\View\GroupListStandingsFreeze.xslt
\code\FootballData\Players\PlayerProfile\View\HeaderPlayerAlsoPlay.xslt
\code\FootballData\Team\TeamClubInfo\View\TeamClubInfo.xslt
\code\FootballData\Team\TeamsCarousel\View\TeamsCarousel.xslt

TEST:
/library/catalog/carousel/_newsticker.html
/library/catalog/carousel/_videoslide.html
/library/catalog/carousel/_photoslide.html
/library/catalog/carousel/_letter.html
/library/catalog/carousel/_letteranchor.html
/library/catalog/carousel/_lettertitle.html   -> /teamsandplayers/players/atoz/index.html (R)
/library/catalog/carousel/_standings.html     -> /uefaeuropaleague/index.html
/library/catalog/carousel/_alsoplaying.html   -> /uefasupercup/season=2013/clubs/player=67496/index.html
/library/catalog/carousel/_alsoplaying2.html  -> /uefasupercup/season=2013/clubs/club=50037/index.html
/library/catalog/carousel/_teamscarousel.html -> /teamsandplayers/index.html

*/
(function ($, win) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  //var trace = d3.Trace;
  //var core = d3.core.getInstance();

  // Default configuration properties.
  var defaults = {
    //**** plugin configuration **** 

    //boolean|selector - true -> default menu | '.selector' -> custom menu in the html
    menu: true,
    //boolean|selector - false -> do nothing |  '.selector' -> find the first element selected in the list and set startitem option 
    first: false,
    //boolean - true -> search combo <select> set start and bind events
    select: false,
    //boolean - true -> before animation search .js-plugin-img-lazy
    lazyimages: false,
    //selector
    counter: '.jcarousel-counter span',
    //boolean - true -> if auto play is true on hover pause animation
    pauseOnHover: true,
    // **** jcarousel settings **** 
    scroll: 3,
    start: 1,
    auto: 0,
    customNumPages : false
  };


  /* 
  * The polling object.
  *
  */
  p3.carousel = function (e, o) {

    /* ------------------------- */
    /* Variables */
    var _this = this;
    var _opt = $.extend(true, {}, defaults, o || {});  //options	
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements
    var _binded = false;

    /* ------------------------- */
    /* Declaring private functions */
    var _itemFirstInCallback, _setupCallback, _loadLazyImages,
        _dom, _domAfterCallback,
        _options, _menu, _bind, _go, _setStart;

    /* ------------------------- */
    //Public Functions
    this.init = function () {

      _dom();

      _options();

      //launch jCarousel
      $dom.jcarousel(_opt);


    };

    //overribles
    //this.onsetup

    /* ------------------------- */
    //Private Functions
    _setupCallback = function (carousel) {

      //DOM - after setup
      _domAfterCallback();

      //external menu
      if ($de.menu.length > 0) {

        //bind events 
        _bind(carousel);


      } else {

        //not external menu - option menu : true
        if (_opt.menu) {

          //append default menu
          _menu(carousel);

          //bind events
          _bind(carousel);

        }
      }

      if (_opt.auto > 0 && _opt.pauseOnHover) {
        // Pause autoscrolling if the user moves with the cursor over the clip.
        carousel.clip.hover(function () {
          carousel.stopAuto();
        }, function () {
          carousel.startAuto();
        });
      }

      if (_opt.auto > 0) {
        carousel.startAuto();
      }

      if ($.isFunction(_this.onsetup)) {
        _this.onsetup(carousel);
      }

    };

    _loadLazyImages = function (c, o, i, s) {
      $(o).find('.js-plugin-img-lazy').lazyImage({animate:true});
    };


    _itemFirstInCallback = function (carousel, item, i, state) {

      var _page = Math.ceil(i / _opt.scroll) - 1;

      if (_opt.menu && $de.handlers && $de.handlers.length > 0) {
        $de.handlers
		    .removeClass("selected")
        .eq(_page)// - 1
        .addClass("selected");
      }

      if (_opt.select) {
        var _label = $de.options
          .prop('selected', false) //.removeAttr('selected')
          .eq(_page)
          .prop('selected', true)  //.attr("selected", "selected")
          .html();

        $de.label.html(_label);
      }

      if ($de.counter.length > 0) {
        //if wrap show one pixel of slide on the right this counter will show wrong counter
        //trace($dom, _page);
        $de.counter.text((_page + 1));
      }

    };


    _options = function () {

      _opt.scroll = Math.max(1, parseInt(_opt.scroll, 10));
      _opt.start = Math.max(1, parseInt(_opt.start, 10));
      _opt.start = Math.max(0, parseInt(_opt.start, 10));

      //TODO: don't works - check \js\core\apps\carousels\newscarmini.source.js if you want infinite logic.
      //attention. the infinite code is very criptic and different to understand. try to avoid to use it.
      if (_opt.wrap === 'circular') {
        _opt.wrap = 'both';
      }

      //set callback
      _opt.setupCallback = _opt.setupCallback || _setupCallback;
      _opt.itemFirstInCallback = _opt.itemFirstInCallback || _itemFirstInCallback;

      //_opt.itemVisibleInCallback = {onAfterAnimation : _onAfterAnimation};
      if (_opt.lazyimages) {
        _opt.itemVisibleInCallback = _opt.itemVisibleInCallback || { onBeforeAnimation: _loadLazyImages };
      }

      //set start item
      if (_opt.first !== false) {
        _setStart();
      }

      if (!_opt.menu) {
        _opt.buttonNextHTML = false;
        _opt.buttonPrevHTML = false;
      }

      //d3.Trace(_opt);
    };

    _setStart = function () {

      var _el = $dom.get(0), _list, _selected, _startitem = 1;

      //find the list of elements - 
      if (_el.nodeName.toUpperCase() === 'UL' || _el.nodeName.toUpperCase() === 'OL') {
        _list = $dom.children('li');
      } else {
        _list = $dom.find('ul,ol').eq(0).children('li');
      }


      _selected = _list.filter(_opt.first);
      if (_selected.length > 0) {
        _startitem = _list.index(_selected);
        _opt.start = _startitem + 1;
      }

    };

    _dom = function () {

      //if counter is yet a jquery object assign it, otherwise is a selector (legacy support)
      $de.counter = _opt.counter.size ? _opt.counter : $dom.find(_opt.counter);

      $de.menu = $dom.find(_opt.menu);

      //external menu - don't append next prev standard
      if ($de.menu.length > 0) {
        _opt.buttonNextHTML = false;
        _opt.buttonPrevHTML = false;
      }

      if (_opt.select) {
        $de.options = $dom.find('option');
        $de.select = $dom.find('select');
        $de.label = $dom.find('span.select');
      }

    };

    _domAfterCallback = function () {
      $de.items = $dom.find(".jcarousel-item").addClass("jc-item");
      $de.bottom = $dom.find(".jcarousel-bottom");

      //show .notactive -> set hide in css layer
      $dom.find('li.notactive').show();
    };

    _menu = function (carousel) {

      var _x, _pages;

      if(_opt.customNumPages){
       _pages = $de.items.size() -2;
      } else{
        _pages = Math.ceil($de.items.size() / _opt.scroll);
      }  

      //trace(_pages, $de.items.size());

      var _html = '<li><a href="#" class="jcarousel-page selected">1</a></li>';

      for (_x = 1; _x < _pages; _x++) {
        _html += '<li><a href="#" class="jcarousel-page">' + (_x + 1) + '</a></li>';
      }

      if (_pages > 1) {
        var _ul = $('<ul />');
        _ul.append(_html).width((_x * 17)).appendTo($de.bottom);
      }

    };


    _bind = function (carousel) {

      //check - this function must be call once
      if (!_binded) {

        //set lock
        _binded = true;

        //cache handlers
        $de.handlers = $dom.find('.jcarousel-page');

        //set go event 
        $de.handlers.click(function () {
          var _p = parseInt($(this).text(), 10);
          _go(carousel, _p);
          return false;
        });

        //external menu - next + prev custom
        if ($de.menu.length > 0) {

          if (!_opt.buttonNextHTML) {
            $de.menu.find('.jcarosuel-next').click(function () {
              carousel.next();
              return false;
            });
          }

          if (!_opt.buttonPrevHTML) {
            $de.menu.find('.jcarosuel-prev').click(function () {
              carousel.prev();
              return false;
            });
          }

        }

        if (_opt.select && $de.select.length > 0) {
          $de.select.change(function () {
            var _goto = parseInt(this.options[this.selectedIndex].value, 10);
            carousel.scroll(_goto);
          });
        }


      }

    };

    _go = function (carousel, page) {

      var _goto = ((page - 1) * _opt.scroll) + 1;
      carousel.scroll(_goto);
    };


  };


} (jQuery, window));

;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

(function ($, win) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var util = d3.util;
  var trace = d3.Trace;
  //var core = d3.core.getInstance();

  // Default configuration properties.
  var defaults = {
    pglib: '/inc/js/core/apps/d3pg/d3pg.js',
    pgcss: '/inc/css/sections/d3pg.css',
    checkparams: false, //standalone version
    loadcss: true, //TODO: resolve this issue
    jsonfeed: '/library/common/photogallery/#ID#/_pgmedia.js',
    photobridge: false,
    //d3pg
    mode: 'single'
  };

  /*
  * The polling object.
  *
  */
  p3.photogallery = function (e, o) {

    /* ------------------------- */
    /* Variables */
    //var _this = this;
    var _opt = $.extend(true, {}, defaults, o || {});  //options
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements
    var _merge;
    /* ------------------------- */
    /* Declaring private functions */
    var _onScriptLoaded, _checkParams, _mergeOptions;

    /* ------------------------- */
    //Public Functions
    this.init = function () {
      //trace(_opt);

      if (_opt.loadcss && !p3.photogallery.prototype.cssloaded) {
        p3.photogallery.prototype.cssloaded = true;
        //win.LazyLoad.css(_opt.pgcss);
        util.appendStyle(_opt.pgcss, 'photogallery');
      }

      $de.target = $dom.is('.d3pg') ? $dom : $dom.find('.d3pg');

      //options photogallery external gallery
      if (_opt.optmerge) {
        _mergeOptions();
      }

      //standalone version use querystring
      if (_opt.checkparams) {
        _checkParams();
      }


      //photostream
      if (_opt.photobridge) {
        _opt.urlLib = win._photobridge; //TODO: refactorize this
      }

      //manage lazyload of the script and init
      if ($.D3pg) {

        _onScriptLoaded();

      } else {


        util.appendScript(_opt.pglib, function () {
          _onScriptLoaded();
        }, 'd3.js.d3pg');

      }


    };


    /* ------------------------- */
    //Private Functions
    _onScriptLoaded = function () {

      $dom.removeClass('js-visibility');

      //trace('init photogallery', $dom, _opt);
      //$de.target.d3pg(_opt);
      //jQuery('#' + $de.target.attr('id')).d3pg(_opt);
      jQuery('.' + $de.target[0].className.split(" ")[0]).d3pg(_opt);

      win.setTimeout(function () {
        $dom.find('.stats.fl').show();
      }, 3000);
    };

    _mergeOptions = function () {

      if ($.metadata) {
        $.metadata.setType('attr', 'data-options');
        _merge = $dom.find(_opt.optmerge).metadata();
      } else {
        _merge = $dom.find(_opt.optmerge).data('options');
      }

      _opt = $.extend(true, {}, _opt, _merge);
      //trace("opt merged:", _opt);

    };

    _checkParams = function () {

      var _params = util.getUrlParameters();
      if (_params.p) {
        var _paddedId = util.getPaddedNewsId(_params.p);
        _opt.urlLib = _opt.jsonfeed.replace('#ID#', _paddedId);
      }
      if (_params.n) {
        _opt.videoid = _params.n;
      } else if (_params.p) {
        _opt.video = {
          url: '/library/news/newsid=' + _params.p + ',relmedia.js',
          news: _params.p
        };
      }

    };

  };


} (jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

/**

REPLACE: function basicPaging(url, elToUpdate, inTabAjax)
\js\base\base.functions.source.js

VIEWS:
- \code\modules\xslt.includes\Navigation\navigationTemplates.xslt
*/

(function ($, win, undefined) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var core = d3.core.getInstance();
  //var trace = d3.Trace;

  // Default configuration properties.
  var defaults = {
    target: '.ajaxclass',
    inTabAjax: false,
    tabAjax: '.ui-tabs-panel, .js-oftabs-panel',
    url: false
  };

  /*
  * The polling object.
  *
  */
  p3.paging = function (e, o) {

    /* ------------------------- */
    /* Variables */
    //var _this = this;
    var _opt = $.extend(true, {}, defaults, o || {});  //options	
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements
    var _binded = false;

    /* ------------------------- */
    /* Declaring private functions */
    var _bind, _onload, _target;
    /* ------------------------- */

    //Public Functions
    this.init = function () {

      //trace(_opt);

      if (_opt.url) {

        _target();


        if (!_binded) {
          _binded = true;
          _bind();
        }

      }

    };


    /* ------------------------- */
    //Private Functions
    _target = function () {

      //legacy code : inTabAjax - passed via option - was the third argument of the function

      if (_opt.inTabAjax) {

        $de.target = $dom.closest(_opt.tabAjax);

      } else {

        //target usually is the row with class ajaxclass setted via cms
        $de.target = $(_opt.target);
      }

      if ($de.target.length === 0) {
        $de.target = $dom.closest('.row');
      }

      //trace($de.target);

    };

    _bind = function () {

      $de.handlers = $dom.find('a');

      $de.handlers.click(function () {

        var _page = $(this).data('page') || $(this).attr('data-page'),//#RETROCOMP
            _url = _opt.url.replace(/\|/g, "/");

        //trace(_page, _url, _page === undefined);

        if (_page !== undefined) {

          if (_page > 1) {
            //_photostream.html -> _photostream,page=2.htmx
            _url = _url.replace('.html', ',page=' + _page + '.htmx');
          }

          $de.target.load(_url, _onload);


        }

        return false;
      });
    };

    _onload = function () {
      var _anchor = win.location.hash,
          $anchor = [];

      if (_anchor !== '') {
        $anchor = $(_anchor);
      }

      if ($anchor.length > 0) {
        win.scrollTo(0, $anchor.offset().top);
      } else {
        win.scrollTo(0, $de.target.offset().top);
      }

      core.parse($de.target);

    };

  };


} (jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

(function ($, win, undefined) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  //var trace = d3.Trace;
  //var core = d3.core.getInstance();

  // Default configuration properties.
  var defaults = {
    lazyimages: '.js-lazywrapper-img'
  };

  /*
  * The lazywrapper object.
  * This plugin is usefull if you want to lazy loading of
  *  - images
  *  - html snippets (TODO)
  * - 1) Images : when you have a block with many images instead of use the class name 
  *      js-lazy that call many times lazyload wrap them with a div and plug this plugin
  *      es: competingClubs in hp of competition have a lots of images. If you use the selector js-lazy
  *          each image when the page scroll down launch the lazyload call about at the same time because them are in same position
  *          in this way instead when the DIV.d3-plugin-lazy data-plugin="lazywrapper" enter in the portview all images will be loaded
  *      the same concept will be implemented to load entire slot (ajax) like corriere.it 
  *      
  */
  p3.lazywrapper = function (e, o) {

    /* ------------------------- */
    /* Variables */
    //var _this = this;
    var _opt = $.extend(true, {}, defaults, o || {});  //options
    var $dom = e; //the jquery element we are working with
    // var $de = {}; //dom elements

    /* ------------------------- */
    /* Declaring private functions */

    /* ------------------------- */
    //Public Functions
    this.init = function () {

      $dom.find(_opt.lazyimages).lazyImage({ animate: false })

      $dom.animate({ "opacity": 1.0 }, 1000);

    };


    /* ------------------------- */
    //Private Functions


  };


} (jQuery, window));
;/* exclude for JSLint parsing */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */
/*global window, document, jQuery */

(function ($, win, undefined) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  //var trace = d3.Trace;
  //var core = d3.core.getInstance();

  // Default configuration properties.
  //var defaults = {};

  /*
  * The skeleton object.
  *
  */
  p3.print = function (e, o) {

    /* ------------------------- */
    /* Variables */
    //var _this = this;
    //var _opt = $.extend(true, {}, defaults, o || {});  //options
    var $dom = e; //the jquery element we are working with
    // var $de = {}; //dom elements

    /* ------------------------- */
    /* Declaring private functions */

    /* ------------------------- */
    //Public Functions
    this.init = function () {

      
        if (!window.jprint) {
          window.jprint = $dom.find('.newsActions .type_print a:visible').jPrint();
        }

        if (window.jprint && !window.jprint.jPrint.hasToken()) {
          var _a = $dom.find('.newsActions .type_mail a:visible,.newsActions .type_share a:visible');

          window.jshare = _a.jShare({ dialogSelector: '.share-dialog' });
          var _href = window.location.href;
          if (_href.indexOf('newsid=') === -1 && _href.indexOf('postid=') === -1) {
            _href = $dom.find('.newsActions .type_print a:eq(0)').attr('href');
          }
          window.jshare.init({ $this: _a, href: _href });
        }
      

    };


    /* ------------------------- */
    //Private Functions


  };


  $(document).ready(function () {
    if ($('.newsActions').length > 0) {
      var _obj = new p3.print($(document), {});
      _obj.init();
    }
  });

} (jQuery, window));
;/* exclude for JSLint parsing */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */
/*global window, jQuery */

(function ($, win, undefined) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var trace = d3.Trace;
  //var core = d3.core.getInstance();

  // Default configuration properties.
  var defaults = {
    version: 1,
    language: 'en'
  };


  p3.langselection = function (e, o) {

    /* ------------------------- */
    /* Variables */
    var _this = this;
    var _opt = $.extend(true, {}, defaults, o || {});  //options 
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements

    /* ------------------------- */
    /* Declaring private functions */
    var _select;

    /* ------------------------- */
    //Public Functions
    this.init = function () {

      //trace("debug - ", _this, $dom, _opt);
      $de.buttons = $dom.find(".langSelection");

      $de.buttons.click(function (e) {
        e.preventDefault();
        _select($(this));
      });

      //3) when the plugin is written use this web tool http://www.jslint.com/ in order to have code well-written

    };


    /* ------------------------- */
    //Private Functions
    _select = function ($btn) {
      $.cookie('esiForcedLanguage', $btn.data('langid'), { expires: 365, domain:'.uefa.com', path: '/' });
      document.location.href = $btn.attr('href');
    };

  };


} (jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

/*
    
DEPENDS:
\js\core\libraries\geotargeting\geotargeting.source.js
  

REPLACE:
- \js\jquery\geo\jquery-geotargeting.MLP.js
- \js\jquery\geo\jquery-geotargeting.sponsor.js
- \js\jquery\geo\jquery-geotargeting.mobile.js  (TODO: call of $j('.geoTargetCont', _self).mobileCoverage({ play: false }) 
-> \js\jquery\jquery.uefa.mobilecoverage.source.js)

VIEWS:
\code\Elements\GeoTargeting\geoIncluder\View\geoIncluder.xslt
\code\Elements\GeoTargeting\geoIncluder\View\geoIncluderMLP.xslt
\code\Elements\GeoTargeting\geoIncluder\View\geoIncluderSponsorHeader.xslt
\code\Elements\GeoTargeting\geoIncluder\View\geoIncluderSponsorEuro.xslt
\code\Elements\GeoTargeting\geoIncluder\View\geoIncluderSponsor.xslt (NOT USED/TESTED)
  
TEST:
/library/catalog/geotargeting/_index1.html  (geoIncluderMLP)
/library/catalog/geotargeting/_index2.html  (geoIncluder)
/library/catalog/randomsponsor/_index2.html (geoIncluderSponsorEuro)
/library/catalog/randomsponsor/_index4.html (geoIncluderSponsorHeader)

*/
(function ($, win, undefined) {

    'use strict';

    //shortcut
    var d3 = win.Deltatre;
    var p3 = d3.plugins;
    var core = d3.core.getInstance();
    //var trace = d3.Trace;

    // Default configuration properties.
    var defaults = {
        yesLink: null,
        noLink: null,
        noLinkOverride: null,
        compName: null,
        countriesAllow: null
    };

    /*
    * The geotargeting plugin.
    *
    */
    p3.geoTargetingIncluder = function (e, o) {

        /* ------------------------- */
        /* Variables */
        //var _this = this;
        var _opt = $.extend(true, {}, defaults, o || {});  //options
        var $dom = e; //the jquery element we are working with
        //var $de = {}; //dom elements
        var geo;

        /* ------------------------- */
        /* Declaring private functions */
        var _ajax;

        /* ------------------------- */
        //Public Functions
        this.init = function () {

            geo = new d3.Geotargeting(_opt);
            geo.whenReady(_ajax);

        };


        /* ------------------------- */
        //Private Functions
        _ajax = function () {

            var _url, _check = true;

            if (_opt.noLinkOverride) {
                _url = _opt.noLinkOverride.replace('/idCountry', 'IT');
            } else if (_opt.noLink) {
                _url = _opt.noLink;
            }
            //TODO: \code\Elements\GeoTargeting\geoIncluder\View\geoIncluderSponsorEuro.xslt
            // pass country=en. probably some views pass anything so it's logic to remove Country. It could be an option (cleanNoLink).
            //else if (_opt.noLink) {
            //_url = _opt.noLink.replace('/Country=', '');
            //}



            if (geo.isValidUrl === 'Y' && _opt.yesLink) {

                //countriesAllow - clean parameter
                if (_opt.countriesAllow) {
                    _opt.countriesAllow = _opt.countriesAllow.toLowerCase().split(',');
                }
                //countriesAllow not setted OR countriesAllow is setted and country is in the array
                _check = !_opt.countriesAllow || (_opt.countriesAllow && $.inArray(geo.getCountry(), _opt.countriesAllow) >= 0);
                //trace(_opt.countriesAllow, geo.getCountry(), $.inArray(geo.getCountry(), _opt.countriesAllow));

                if (_check) {
                    _url = _opt.yesLink.replace('/idCountry', geo.getCountry());
                }
            }

            //d3.Trace("NEW geoTargetingIncluder - ",_url);


            if (_url.length > 0 && _url !== win.location.pathname) {
                $.get(_url, function (html) {
                    var $html = $(html);

                    if (_opt.methodToCall !== undefined && _opt.methodToCall !== '' && typeof window[_opt.methodToCall] === 'function') {
                        $html = window[_opt.methodToCall]($html);
                    }

                    $dom.find('.js-target').html($html);

                    core.parse($html);
                });
            }

        };

    };



} (jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre, SCW */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */


/*


1) REPLACE CODE INLINE:
\code\Templates\Elements\Menu\Level3\PromoEuro2016.xslt
\code\Templates\Elements\Menu\Level3\RandomPromoEuro2016.xslt

DEPENDS:
\js\core\libraries\geotargeting\geotargeting.source.js

VIEWS:
- \code\Templates\Elements\Menu\Level3\PromoEuro2016.xslt
- \code\Templates\Elements\Menu\Level3\RandomPromoEuro2016.xslt

TEST:
/library/catalog/randomsponsor/_index3.html?isdebug


2) REPLACE CODE:
\js\jquery\sponsors\jquery.randomsponsor.js

VIEWS:
- \code\Elements\GeoTargeting\sponsorIncluder\View\RandomPromo_new.xslt

TEST:
/library/catalog/randomsponsor/_index4.html?isdebug

*/
(function ($, win) {

	'use strict';

	//shortcut
	var d3 = win.Deltatre;
	var p3 = d3.plugins;
	//var trace = d3.Trace;
	//var core = d3.core.getInstance();

	// Default configuration properties.
	var defaults = {
		randomize: true,
		geotargeting: true,
		trackatstart: false,
		items: [],
		extract: 2,
		force: undefined,
		weighted: undefined,
		datasponsor: undefined,
		datascope: undefined,
		datatrack: undefined,
		views: {
		  random_list: '<div class="random_list clearfix" />',
      survey_list: '<div class="random_list clearfix container" />'
		}
	};

	/*
	* The polling object.
	*
	*/
	p3.randomsponsors = function (e, o) {

		/* ------------------------- */
		/* Variables */
		//var _this = this;
		var _opt = $.extend(true, {}, defaults, o || {});  //options
		var $dom = e; //the jquery element we are working with
		var $de = {}; //dom elements
		var geo, isRetina;

		var _extracted = [];

		/* ------------------------- */
		/* Declaring private functions */
		var _do, _combine, _checkOnlyLang, _extractFirsts, _writeExtracted, _getListItemBg, _getListItemImg, _trackAtStart, _getRandomByWeight;
		/* ------------------------- */
		//Public Functions
		this.init = function () {

			//dom
			$de.target = $dom.find('.js-target');
			if (!$de.target.length) {
				$de.target = $dom;
			}
			// Check if retina images are needed
			isRetina = $('html').hasClass('pixelRatio-2x');

			if (_opt.geotargeting) {
				geo = new d3.Geotargeting(_opt);
				geo.whenReady(_do);
			} else {
				_do();
			}


		};


		/* ------------------------- */
		//Private Functions
		_do = function () {

			//trace(_opt);

			if (_opt.randomize) {
				_combine();
			} else {
				if (_opt.geotargeting) {
					_checkOnlyLang();
				} else {
					_extractFirsts();
				}
			}

			_writeExtracted();

			if (_opt.trackatstart) {
				_trackAtStart();
			}


		};

		_checkOnlyLang = function () {
			var _currentLanguage = geo.getCountry();

			$.each(_opt.items, function (k, v) {

				if (_extracted.length >= _opt.extract) {
					return false; //exit each
				}

				if (v.nocountry) {
					if (v.nocountry.toUpperCase().split(',').indexOf(_currentLanguage.toUpperCase()) === -1) {
						_extracted.push(v);
					}
				} else {
					_extracted.push(v);
				}


			});

		};

		_extractFirsts = function () {
			_extracted = _opt.items.slice(0, _opt.extract);
		};

		_trackAtStart = function () {

			var _track = false, _titles = [];

			$.each(_extracted, function (k, v) {

				if (v.track === 'Y') {
					_titles.push(v.title.toLowerCase());
					_track = true;
				} else {
					_track = false;
				}

			});

			if (_track) {
				//trace(_titles.join(' | '));
				win.SCW.TL(this, 'o', 'Tool Used', {
					linkTrackVars: 'events,eVar43',
					linkTrackEvents: 'event20',
					events: 'event20',
					eVar43: 'top sponsors views - ' + _titles.join(' | ')
				});
			}

		};



		_combine = function () {

			var _rnd,
					_item,
					_attemps = 0,
					_max_attempts = _opt.items.length,
					_to_extract = _opt.extract,
					_currentLanguage = geo ? geo.getCountry() : false;

			//trace(_opt.items.length);


			//extract random elements and push in _extracted
			while (_to_extract > 0) {

				if (_attemps >= _max_attempts) {
					break;
				}

				//UEL - index 0 extracted as first sponsor ALWAYS
				//trace(_opt.force);
				if (_opt.force !== undefined && _opt.force.length > 0) {
					_rnd = _opt.force.pop();
				} else if (_opt.weighted !== undefined && _opt.weighted.toLowerCase() === 'y') {
					_rnd = _getRandomByWeight();
				} else {
					_rnd = Math.floor(Math.random() * (_opt.items.length));
				}

				//trace(_opt.items.indexOf(_opt.items[_rnd]));

				//extract element - reindex original array for next extract
				_item = _opt.items.splice(_opt.items.indexOf(_opt.items[_rnd]), 1).pop();

				//trace(_item, _opt.items.length);
				//trace(_currentLanguage);
				//trace("sp " + _item.title + "no_country:" + _item.nocountry);
				if (_currentLanguage) {
					if (!(_item.nocountry && _item.nocountry.toUpperCase().split(',').indexOf(_currentLanguage.toUpperCase()) > -1)) {
						_extracted.push(_item);
						_to_extract--;
					}
				} else {
					_extracted.push(_item);
					_to_extract--;
				}

				_attemps++;
				//trace("Attempts - extract:", _attemps, _opt.extract);
			}

			//trace(_extracted);
		};

		_getRandomByWeight = function () {

			var _extr;

			//creo una mappa di valori massimi basati sulla chiave peso (base 100) di ogni elemento.
			var _arr_weight = [], _max = 0;
			$.each(_opt.items, function (k, v) {
				_max += v.weight;
				_arr_weight.push(_max);
			});

			//estraggo un random in base 100
			var _rnd = Math.floor(Math.random() * 100) + 1;

			_extr = 0;

			$.each(_arr_weight, function (k, v) {

				_extr = k;

				if (_rnd < v) {
					return false; //Exit each;
				}

			});

			return _extr;
		};

		_writeExtracted = function () {

			var _links, _titles, $li, $wrap, $ul;


			$ul = $('<ul />');

			if (_opt.views[_opt.view]) {
				$wrap = $(_opt.views[_opt.view]); //$('<div class="random_list clearfix" />');
				$ul.appendTo($wrap);
			} else {
				$wrap = $ul;
			}



			$.each(_extracted, function (k, v) {

				_links = v.url.split('|');
				_titles = v.title.split('|');

				$li = v.width ? _getListItemImg(v, _links, _titles) : _getListItemBg(v, _links, _titles);

				//append html
				$ul.append($li);

			});


			$de.target.append($wrap);

		};

		_getListItemImg = function (obj, links, titles) {

			var $a;

			//d3.Trace(obj);

			$a = $('<a>')
			.attr({
				title: obj.title || '',
				href: obj.url || '#',
				'data-track': obj.track || ''
			})
			.click(function (e) {

				if (obj.url) {
					window.open(obj.url, '_blank');
				}
				if (obj.track && obj.track.toLowerCase() === 'y') {
					SCW.TL(this, 'o', 'Tool Used', {
						linkTrackVars: 'events,eVar43',
						linkTrackEvents: ' event20',
						events: 'event20',
						eVar43: 'top sponsors click - ' + obj.title.toLowerCase()
					});
				}

				e.preventDefault();
			});

			$('<img>').attr({
				width: obj.width,
				height: obj.height,
				src: (isRetina && obj.retina) ? obj.retina : obj.src,
				title: obj.title || ''
			}).appendTo($a);

			return $('<li>').attr({
				'data-sponsor': obj.datasponsor || '',
				'data-scope': obj.datascope || '',
				'data-track': obj.datatrack || ''
			}).append($a);
		};

		_getListItemBg = function (obj, links, titles) {


			var _linkClassName = links.length > 1 ? "half-link" : "single-link",
					_html = [];

			_html.push('<li data-sponsor="' + obj.datasponsor + '" data-scope="' + obj.datascope + '" data-track="' + obj.datatrack + '"><div class="promo" style="background-image:url(' + ((isRetina && obj.retina) ? obj.retina : obj.src) + ');' + ((isRetina && obj.retinaw && obj.retinah) ? ('background-size:' + obj.retinaw + 'px ' + obj.retinah + 'px;') : '') + '">');

			$.each(links, function (k, v) {
				_html.push('<a class="' + _linkClassName + '" href="' + v + '" title="' + titles[k] + '" target="_blank">&nbsp;</a>');
			});

			_html.push("</div></li>");

			return _html.join('');

		};



	};


} (jQuery, window));
;/* exclude for JSLint parsing */

/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true, continue: true  */
/*global window, jQuery */

(function ($, win) {
  'use strict';

  //shortcuts
  var 
	d3 = win.Deltatre,
	p3 = d3.plugins,
	defaults = {
	  updateInterval: 20000,
	  verticalSpacing: 16,
	  numPages: 5,
	  api: false,
	  jsonp: false,
	  url: 'http://api.chartbeat.com/toppages/',
	  host: 'en.uefa.com',
	  key: '95eaf0cc232017462913d634662dd252',
	  section: 'ucl-news',
	  animDuration: 1000,
	  nvisitors: false,
	  showtrend: true,
	  trendby: 'visitors', //position - visitors
	  showpos: true,
	  target: '.js-chartbeat-trending',
	  cleanTitles: false,
	  addOddClass: false
	};

  //////////////////////////////////////////////////////////////////////
  /**
  * Main widget, that drives the entire display.
  *
  * @param {string|e} element Element to show the widget in.
  * @param {string|o} options parameter in the widget in.
  * {string} host Hostname to show top pages for.
  * {string} apiKey API key to use.
  * {string} regexp Regular expression of paths to ignore.
  * {string} updateInterval update interval
  * @constructor
  */
  p3.trending = function (e, o) {

    /* -----------*/
    /* Variables */
    var 
		$dom = e,
		_opt = $.extend({}, defaults, o || {}),
		$de = {},
		_pages = {}, //Dictionary of currently shown pages
		_ignoreExpr = _opt.regexp ? new RegExp(_opt.regexp) : null,
		_url;

    /* ------------------------- */
    /* Declaring private functions */
    var _dom, _start, _update, _onData, _setUrl, _addOddClass, _filterDataWithUrl;


    this.init = function () {
      /* 
      DEBUG GOLD: decomment this, rename data2.json json in the filer in order to avoid conflict with the one of the worker.
      _opt.updateInterval = 5000;
      _opt.url = _opt.url.replace('data.json', 'data2.json');
      */

      _dom();
      _setUrl();

      _start(true);
    };

    /* ------------------------- */
    //Private Functions

    _addOddClass = function () {
      if (_opt.addOddClass) {
        $(_opt.target + " li").removeClass("odd");
        $(_opt.target + " li:odd").addClass("odd");
      }
    };

    _dom = function () {
      $de.target = $(_opt.target, $dom);
      $de.ul = $('<ul />').appendTo($de.target);
    };
    /**
    * set api url entrypoint (chartbeat/uefa layer)
    */
    _setUrl = function () {

      if (_opt.api) {
        var _arr = [],
				_params = {
				  host: _opt.host,
				  apikey: _opt.key,
				  limit: _opt.numPages,
				  jsonp: '?'
				};
        if (_opt.section && _opt.section.length > 0) {
          _params.section = _opt.section;
        }

        $.each(_params, function (k, v) {
          _arr.push(k + '=' + v);
        });
        _url = _opt.url + '?' + _arr.join('&');
      } else {
        _url = _opt.url;
      }
    };

    /**
    * Starts fetching of the backend data, and the main widget
    * functionality.
    */
    _start = function (fire) {
      /*
      Set up general click handler
      Start fetching data
      */

      if (fire) {
        _update();
      } else {
        win.setTimeout(_update, _opt.updateInterval);
      }


    };

    /**
    * Update the backend data.
    * @private
    */
    _update = function () {
      // Set up backend /toppages call. The full API documentation can be
      // found here: http://chartbeat.pbworks.com/toppages
      //$.getJSON(uri,this.onData_);
      $.ajax({
        type: "GET",
        url: _url,
        cache: false,
        dataType: _opt.jsonp || _opt.api ? "jsonp" : "json", //TODO : jsonp override callback ($ 1.3.2 not compatible)
        success: function (data) {

          data = _filterDataWithUrl(data);
          _onData(data);
          _addOddClass();
          _start(false);
        }
      });
    };

    _filterDataWithUrl = function (data) {
      var _keys = {};
      var _data = $.grep(data, function (v, i) {
        if (v.path && v.path !== null && !_keys[v.path]) {
          _keys[v.path] = true;
          return true;
        }
      });
      return _data;
    };

    /**
    * Called when new data is received from the backend.
    *
    * @param {Array.<Object>} data Data received from server
    *
    * @private
    */
    _onData = function (data) {

      //var self = this;
      var siteContext, language = window.LANG;
      if (!data) {
        return;
      }

      // This is used to build up a new this.pages dictionary. All
      // objects used from this.pages will be moved from this.pages into
      // newpages. Thus, at the end of the for loop, this.pages will
      // contain all the unused objects -- which should be removed.
      var _newpages = {}, _ypos = 4, _i, _el, _page, _position = 1, _valid = -1;
      for (_i = 0; _i < data.length; _i += 1) {
        _page = data[_i];


        //console.log(_page.i.length, _page.i);
        if (_page.i.length === 0) {
          continue;
        }

        if (_page.path && _page.path.indexOf('translate_c') !== -1) {
          continue;
        }

        if (_ignoreExpr && _ignoreExpr.test(_page.path)) {
          continue;
        }

        if (_page.path && _page.path.indexOf('#') !== -1) {
          _page.path = _page.path.substring(0, _page.path.indexOf('#'));
        }


        // START GESTIONE CROSS DOMAIN - SITE CONTEXT
        if (_page.path.indexOf("http:") === -1) {
          if (_page.siteContext === "2") {
            if (window.location.host.indexOf(".com") != -1) {
              _page.path = window.location.host.replace(".com", ".org") + _page.path;
            } else {
              _page.path = window.location.host + _page.path;
            }
          } else {
            if (window.location.host.indexOf(".org") != -1) {
              _page.path = window.location.host.replace(".org", ".com") + _page.path;
            } else {
              _page.path = window.location.host + _page.path;
            }
          }
          _page.path = window.location.protocol + "//" + _page.path;
        }
        // END GESTIONE CROSS DOMAIN - SITE CONTEXT


        _valid++;
        _position = _valid + 1;
        _el = _pages[_page.path];

        if (_el) {
          // Page already shown
          delete _pages[_page.path];
          _el.setVisitors(_page.visitors);
          _el.setPosition(_position);
          _el.slideTo(_ypos);
        } else {
          /* reset first element */
          if (_position == 1) $de.ul.find("li.first").removeClass("first");
          _el = new p3.trendingpage(_opt, _page, _position, _ypos);
          $de.ul.append(_el.element);
          _el.element.fadeIn();
        }

        _newpages[_page.path] = _el;
        _ypos += _opt.verticalSpacing;

        if (_position >= _opt.numPages) {
          break;
        }
      }

      //removed Pages from the list
      $.each(_pages, function (i, elem) {
        elem.fadeOutAndRemove();
      });

      // New currently shown pages dict
      _pages = _newpages;

      $dom.css({
        opacity: 1
      });

      $de.target.height(_opt.verticalSpacing * _position);

    };
  };

  /**
  * Widget that shows an individual page (i.e. row).
  *
  * @param {string} options.
  * @param {string} page json object.
  * @param {number} ypos Y position of element (px).
  *
  * @constructor
  */
  p3.trendingpage = function (options, page, position, ypos) {
    /* -----------*/
    /* Variables */
    var 
			self = this,
			_opt = options,
			_count = page.visitors, //Current number of visitors shown.
			_position = position, //Current number of visitors shown.
			_flagFadeByVisitors = false,
			_flagFadeByPosition = false,
			_title = _opt.api || _opt.cleanTitles ? page.i.replace(' ' + "\u2013" + ' UEFA.com', "") : page.i,
			$dom = $('<li>').attr({ "class": "page" + (_position == 1 ? " first" : "") }).css({ "display": "none", "top": +ypos + "px" }),
			$rel = $('<div>').attr({ "class": "rel" }).appendTo($dom),
			$heading = $('<h4>').attr({ "class": "nTitle" }).appendTo($rel),
			$de = {};

    $("<a>").attr({ "href": page.path }).text(_title).appendTo($heading);

    /* ------------------------- */
    /* Declaring private functions */
    var _trendElement, _visitorsElement, _positionElement, _addOddClass;

    /* ------------------------- */
    //Public interface
    this.element = $dom;

    /**
    * Slide the element to new Y position.
    * @param {number} ypos New Y position (px)
    */
    this.slideTo = function (ypos) {
      var pos = $dom.position();
      var _callback = function (msec) {
        win.setTimeout(function () {
          self.fadePosition('position', 'trend');
        }, (2000 + msec));
      };

      self.fadePosition('trend', 'position', function () {
        if (pos.top !== ypos) {
          $dom.animate({ top: ypos }, _opt.animDuration, function () {
            _callback(0);
            _addOddClass();
          });
        } else {
          _callback(_opt.animDuration);
          _addOddClass();
        }
      });
    };

    this.fadePosition = function (show, hide, callback) {
      //if (_fadepos) {
      //  console.log(_title, _fadepos);
      //}
      if ((_flagFadeByVisitors || _flagFadeByPosition) && _opt.showtrend && _opt.showpos) {
        $de[hide].fadeOut('slow', function () {
          $de[show].fadeIn('slow');
        });
      }

      if ($.isFunction(callback)) {
        callback();
      }
    };

    /**
    * Set the current number of visitors.
    *
    * @param {number} count New visitor count.
    */
    this.setVisitors = function (count) {
      //console.log(_title, count, _count, count > _count);

      if (_opt.showtrend && _opt.trendby === 'visitors') {
        _flagFadeByVisitors = true;
        if (count === _count) {
          _flagFadeByVisitors = false;
        }
      }

      if (count === _count) {
        return;
      }

      if (_opt.nvisitors) {
        $de.visitors.text(count);
      }

      if (_opt.showtrend && _opt.trendby === 'visitors') {
        this.setTrend(count > _count);
      }

      _count = count;
    };

    this.setPosition = function (position) {

      if (_opt.showtrend && _opt.trendby === 'position') {
        _flagFadeByPosition = true;
        if (position === _position) {
          _flagFadeByPosition = false;
        }
      }

      if (position === _position) {
        return;
      }

      if (_opt.showpos) {
        $de.position.text(position);
        /*set a specific class to that actual first element */
        if (position == 1) {
          $de.position.parents("ul").find("li.first").removeClass("first");
          $de.position.parents("li").addClass("first");
        }
      }

      if (_opt.showtrend && _opt.trendby === 'position') {
        this.setTrend(position < _position);
      }

      _position = position;
    };

    this.setTrend = function (up) {
      $de.trend.attr("src", up ? "/imgml/icons/up.png" : "/imgml/icons/down.png");
    };

    /**
    * Fade out the widget, and dispose it.
    */
    this.fadeOutAndRemove = function () {

      $dom.fadeOut('slow', function () {
        $dom.remove();
        $dom = null;
      });
    };

    /* ------------------------- */
    //Private Functions

    _addOddClass = function () {
      if (_opt.addOddClass) {
        $(_opt.target + " li").removeClass("odd");
        $(_opt.target + " li:odd").addClass("odd");
      }
    };

    /**
    * Image showing the current trend of the page (up/down).
    */
    _trendElement = function () {
      $de.trend = $("<img>")
									.attr({ "src":
										"/imgml/void.gif",
									  "width": "16",
									  "height": "16",
									  "class": "trend"
									})
									.prependTo($rel).hide();
    };

    /**
    * Element showing the number of visitors on the page.
    */
    _positionElement = function () {
      $de.position = $("<span>")
											.attr({ "class": "position" })
											.text(_position)
											.prependTo($rel);
    };
    /**
    * Element showing the number of visitors on the page.
    */
    _visitorsElement = function () {
      $de.visitors = $("<span>")
											.attr({ "class": "visitors" })
											.text(_count)
											.prependTo($rel);
    };

    /* ------------------------- */
    //Constructor Area
    if (_opt.showtrend) {
      _trendElement();
    }

    if (_opt.nvisitors) {
      _visitorsElement();
    }

    if (_opt.showpos) {
      _positionElement();
    }
  };
} (jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true */

/*

Replace code inline written in
\code\UReader\v2\Container\View\Grid12.xslt
\code\UReader\v2\Container\View\Container.xslt

Depends on:
\js\core\libraries\uefa-live\uefalive.source.js
*/
(function ($, win, AreaTagger) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var trace = d3.Trace;
  var core = d3.core.getInstance();

  // Default configuration properties.
  var defaults = {
    islegacy: false, //uefaLive option
    timestamp: null,
    timeout: null,
    urlcheck: null,
    urlget: null,
    empty: true,
    haspromo: false,
    fixheight: false,
    callbackCheck: false,
    hp: false
  };

  /*
  * The polling object.
  *
  */
  p3.ureader = function (e, o) {

    /* ------------------------- */
    /* Variables */
    var _this = this;
    var _opt = $.extend(true, {}, defaults, o || {});  //options	
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements
    var _promo;

    /* ------------------------- */
    /* Declaring private functions */
    var _parseHtml, _setTitles, _setHeight,
        _initSlots, _initSlot,
        _reInit,
        _cachePromo, _trackHpLinks,
        _callbackCheck;


    /* ------------------------- */
    //Public Functions
    this.init = function () {

      //trace("init ureader");
      //trace($dom);

      $de.parent = $dom.parent();

      _parseHtml();

      if (_opt.haspromo) {
        _cachePromo();
      }

      _opt.callback = _reInit;
      if (_opt.callbackCheck) {
        _opt.callbackCheck = _callbackCheck;
      }
      //_opt.timeout = 10000; //DEBUG

      _initSlots();

      $dom.uefaLive(_opt);

      if (_opt.hp) {
        _trackHpLinks();
      }
    };

    /* ------------------------- */
    //Private Functions
    _reInit = function (html) {

      var _html = $(html);

      //trace(_html);

      if (_opt.haspromo) {
        _html.find(".promo").empty().find(".ADBox").empty();

        //TODO : move this
        $('#urmtooltip').remove();

        //update $dom - NB: html replace old html
        $de.parent
        .html(_html)
        .find(".promo")
        .append(_promo.html());

      } else {

        $de.parent
        .html(_html);

      }

      //relaunch plugin
      core.parse(_html);

    };

    _cachePromo = function () {
      _promo = $dom.find('.promo');
      _promo.find("script, noscript").remove();
    };

    _parseHtml = function (html) {
      if (_opt.fixheight) {
        _setHeight();
      }
      _setTitles(html);
    };

    _setHeight = function () {

      var _medHeight = 0;

      $dom.find('.slot.medium').each(function () {
        var _h = parseInt($(this).height(), 10);
        if (_h > _medHeight) {
          _medHeight = _h;
        }
      });

      $dom.find('.slot.medium .layer').each(function () {
        $(this).css('height', _medHeight + 'px');
      });

    };


    _setTitles = function (html) {
      var html = html || $dom;
      //trace("Test set titles:", html, $(html, $dom).find('.headline a'));

      $(html, $dom).find('.headline a').each(function () {
        $(this).attr("title", $(this).text());
      });

    };

    _initSlots = function () {

      $de.slots = $dom.find('.js-ureader-slot');
      //TODO: trace($dom, $de.slots);

      $de.slots.each(function () {

        var $slot = $(this);
        _initSlot($slot);

      });

    };


    _initSlot = function ($slot) {

      //RETROCOMP CODE - REMOVE when base.js will replace main.js
      var _o;


      if ($.metadata) {
        $.metadata.setType('attr', 'data-options');
        _o = $slot.metadata();
      } else {
        _o = $slot.data('options');
      }

      if (_o !== undefined) {

        _o.islegacy = false;

        _o.callback = function (html) {

          var _html = $(html);

          $slot.html(_html);

          core.parse(_html);

          //reinit polling
          //_initSlot(_html);

          _parseHtml(_html);

        };

        //DEBUG:
        //_o.timeout = 5000;

        //TODO: trace('init slot:', $slot);
        $slot.uefaLive(_o);
      } else {
        trace('ureader - live not initialized - options not valid:', $slot, _o);
      }

    };


    _callbackCheck = function (data) {
      if (data && data.background) {
        $dom.find('.js-background').css('background-color', data.background);
      }
    };

    _trackHpLinks = function () {

      //TODO: TEST:
      $dom.find('.slot').each(function () {
        $(this).click(function () {
          var _elem = $(this);
          var eVar46 = "ureader - slot " + _elem.attr('id').substr(4);
          SCW.TL(this, 'o', 'HP Content Area Click', {
            linkTrackVars: 'eVar46,events',
            linkTrackEvents: 'event3',
            events: 'event3',
            eVar46: eVar46
          });
        });
      });

    };


  };


} (jQuery, window, window.AreaTagger));
;/* exclude for JSLint parsing */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */
/*global window, jQuery */

/*

VIEWS:
\code\Elements\Group\View\GroupListStandings.xslt
\code\Elements\Group\View\GroupListStandingsNewHp.xslt
\code\Elements\Group\View\GroupListStandingsFreeze.xslt

TEST:
/library/catalog/carousel/_standings.html
*/

(function ($, win, undefined) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var core = d3.core.getInstance();
  //var trace = d3.Trace;
  
  // Default configuration properties.
  var defaults = {
    url: undefined,
    cup: undefined,
    current: 1
  };

  /*
  * The skeleton object.
  *
  */
  p3.standings = function (e, o) {

    /* ------------------------- */
    /* Variables */
    var _opt = $.extend(true, {}, defaults, o || {});  //options
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements
    var _binded = false,
        _locked = false,
        _last = _opt.current;

    /* ------------------------- */
    /* Declaring private functions */
    var _bind, _onload;

    /* ------------------------- */
    //Public Functions
    this.init = function () {

      $de.target = $dom.find('#groups_stands_' + _opt.cup);
      $de.handlers = $dom.find("#grlist").find("li");

      $dom.find('#gr' + _opt.current).addClass('current');

      if ($de.target.length > 0 && !_binded) {
        _binded = true;
        _bind();
      }
    };


    /* ------------------------- */
    //Private Functions
    _bind = function () {

      $de.handlers.click(function () {

        var _el = this, _url,
             _groupID = _el.id.replace('gr', '');

        if (_last !== _groupID && !_locked) {
          _url = _opt.url.replace('[group]', _groupID).replace('{group}', _groupID);

          _locked = true;
          $de.target.load(_url, function () {
            _onload($(_el), _groupID);
          });

        }

        return false;

      });

    };

    _onload = function ($el, id) {

      core.parse($de.target);

      $de.handlers.removeClass('current');
      $el.addClass('current');

      _last = id;
      _locked = false;

    };

  };


} (jQuery, window));
;; (function($) {

	$.UreaderMatches = {
		show_delay: 300,
		id: false,
		timeout: false,
		cancelTimeout: function(who) {
			clearTimeout($.UreaderMatches.timeout);
			$.UreaderMatches.timeout = false;
			//console.log(who);
		},
		onReady: function() {

			//disabilita link
			//$('.ureader .matches a.disabled').attr("href", "#");

			var _in_liveblogging = $('body.live-coverage').length > 0;

			$('.js-urMatches a.disabled').click(function(ev) {
				ev.stopPropagation();
				return false;
			}).css("cursor", "default");

			//sposta il tooltip al fondo (si duplicano)
			$('#urmtooltip:gt(0)').remove();
			var _tpl = $('#urmtooltip').appendTo('body');

			$('.js-urMatches .urmtab').each(function() {
				var that = $(this),
					_context = that.parents(".matches:eq(0)");

				if (that.is('ul')) {
					var _li = $('li', that);

					$('a', that).each(function(nr) {

						$(this).click(function() {

							$(_li).removeClass("selected").eq(nr).addClass("selected");

							$('.js-urMatches .session', _context).hide().eq(nr).show();

							//TODO: $('#ur_matches .session:visibile').MatchesFixLineHeight();

							return false;
						});
					});
				} else if (that.is('select')) {
					that.on('change', function() {
						var nr = that.prop('selectedIndex');
						
						$('.js-urMatches .session', _context).hide().eq(nr).show();
					});
				}

			});

			//TODO: $('#ur_matches .cols3:visibile').MatchesFixLineHeight();



			var _tpldom = {
				img: $('#urm_tlp_img', _tpl),
				imgl: $('#urm_tlp_img_lnk', _tpl),
				headline: $('#urm_tlp_h', _tpl),
				headlinel: $('#urm_tlp_h_lnk', _tpl),
				title: $('#urm_tlp_t', _tpl),
				titlel: $('#urm_tlp_t_lnk', _tpl),
				teamhome: $('#urm_tlp_th', _tpl),
				teamaway: $('#urm_tlp_ta', _tpl),
				standing: $('#urm_tlp_st', _tpl),
				presskit: $('#urm_tlp_pk', _tpl),
				link: $('#urm_tlp_gm', _tpl),
				wtext: $('div.text', _tpl),
				wGr: $('.tC', _tpl),
				bB: $('.bB', _tpl),
				button: $('.bB .button', _tpl)
			};

			if (!_in_liveblogging) {
				_tpl.find("a").click(function() {
					//OMNITURE - START (TOOLTIP LINK)
					try {
						var eVar46 = SCW.ContentProperties["sec"] + " - ureader - popup matches";
						SCW.TL(this, 'o', 'HP Content Area Click', {
							linkTrackVars: 'eVar46,events',
							linkTrackEvents: 'event3',
							events: 'event3',
							eVar46: eVar46
						});
					} catch (e) {
						if (console && console.log) {
							console.log(e);
						}
					}
					//OMNITURE - END
				});
			}
			var _arR = _tpl.find(".arR");
			var _arL = _tpl.find(".arL");
			var $li_matches = $('.js-urMatches .column li');
			var _getPos = function(el) {
				var _p1 = $(this).position();
				var _ret = _p1;
				_ret.top += _posUreader.top;
				_ret.left += _posUreader.left;
			};
			var _build_tooltip = function(el, data) {

				$('.mr', _tpl).remove();
				_tpldom.bB.attr("class", "bB");

				if (data.img) {
					_tpldom.imgl.attr("href", data.link);
					if (!data.thumb_loaded) {
						_tpldom.img.one("load", function() {
							$(this).css("visibility", "visible");
							data.thumb_loaded = true;
						}).css("visibility", "hidden").attr("src", data.img);
					} else {
						_tpldom.img.attr("src", data.img);
					}
				} else {
					return false;
				}
				if (data.title) {
					_tpldom.titlel.attr("href", data.link);
					_tpldom.title.text(data.title);
				} else {
					return false;
				}
				if (data.NewsKind) {
					_tpldom.headlinel.show().attr("href", data.link);
					_tpldom.headline.text(data.NewsKind);
				} else {
					_tpldom.headlinel.hide();
				}
				if (data.matchlink) {
					_tpldom.link.attr("href", data.matchlink);
				} else {
					return false;
				}
				if (data.teamhome) {
					_tpldom.teamhome.show().find("a").attr("href", data.teamhomel).text(data.teamhome);
				} else {
					_tpldom.teamhome.hide();
				}
				if (data.teamaway) {
					_tpldom.teamaway.show().find("a").attr("href", data.teamawayl).text(data.teamaway);
				} else {
					_tpldom.teamaway.hide();
				}
				if (data.standing) {
					_tpldom.standing.show().find("a").attr("href", data.standing);
				} else {
					_tpldom.standing.hide();
				}
				if (data.presskit) {
					_tpldom.presskit.show().find("a").attr("href", data.presskit);
				} else {
					_tpldom.presskit.hide();
				}


				if (data.rplhtml.size() > 0 || data.hghhtml.size() > 0) {
					if (data.rplhtml.size() > 0) {
						_tpldom.button.append(data.rplhtml);
						_tpldom.bB.addClass("replay");
					}
					if (data.hghhtml.size() > 0) {
						_tpldom.button.append(data.hghhtml);
						_tpldom.bB.addClass("freehigh");
					}
					if (data.rplhtml.size() > 0 && data.hghhtml.size() > 0) {
						_tpldom.bB.addClass("highreplay");
					}
				}

				_tpl.addClass("abshide").show();
				var _h = _tpldom.wtext.height();

				/* #TLPH
				if (_h > 114) {//min-height CSS
				_tpldom.wGr.height((_h - 76)); //bottom tooltip height
				}*/

				_tpldom.wGr.css("height", "auto");
				if (_h > 83) {//min-height CSS
					_tpldom.wGr.height((_h - 46)); //bottom tooltip height
				}

				_tpl.hide().removeClass("abshide");

				return true;
			};
			var _init_tooltip = function(el, col3) {
				var _data = $(el).data("MatchTooltip");
				return _show_tooltip(el, _data, col3);
			};
			var _show_tooltip = function(el, data, isRight) {
				return setTimeout(function() {
					var _pos = $(el).offset();
					var _w = $(el).width();
					var _isCol2 = $(el).parents('.session.cols2').size() > 0;
					var _isCol1 = $(el).parents('.session.cols1').size() > 0; //#1col
					_pos.top -= 36;

					if (_isCol2 || _isCol1) {
						_pos.top += 7;
					}

					if (isRight) {
						if (_isCol2 || _isCol1) {//#1col
							_pos.left = _pos.left - (_w - 175);
						} else {
							_pos.left = _pos.left - (_w - 15); // - 15 | + 12
						}
					} else {
						_pos.left = _pos.left + _w;
					}
					var _bool = _build_tooltip(el, data);
					if (isRight) {
						_tpl.addClass("tlpR");
						//_arR.hide();
						//_arL.show();
					} else {
						_tpl.removeClass("tlpR");
						//_arR.show();
						//_arL.hide();
					}
					if (_bool) {
						$(el).addClass("hover");
						_tpl.css(_pos).fadeIn("slow");
					}
				}, $.UreaderMatches.show_delay); //500
			};

			$li_matches.each(function() {

				//col1
				var _isCol1 = $(this).parents('.session.cols1').size() > 0;
				//if (_isCol1) {
				//  return false;
				//}

				//#1col
				var _tlpR = _isCol1 || $(this).parents('.column.col3, .session.cols2 .column.col2').size() > 0;
				var _el = this;

				var _href_mtc = $('.urmmatch a', _el).attr("href");
				if (_href_mtc !== undefined && _href_mtc.length > 0) {

					$(_el).click(function() {


						//OMNITURE - START (MATCH LINK)
						try {
							if (!_in_liveblogging) {
								var eVar46 = SCW.ContentProperties["sec"] + " - ureader - matches";
								SCW.TL(this, 'o', 'HP Content Area Click', {
									linkTrackVars: 'eVar46,events',
									linkTrackEvents: 'event3',
									events: 'event3',
									eVar46: eVar46
								});
							}
						} catch (e) {
							if (console && console.log) {
								console.log(e);
							}
						}
						//OMNITURE - END
						var _href_mtc = $('.urmmatch a', this).attr("href");
						location.href = _href_mtc;
						return false;
					});
				}

				//fix lineheight
				$(_el).mouseenter(function(ev) {
					$.UreaderMatches.id = _el.id;
					//console.log("MATCHID >> ", $.UreaderMatches.id);
					$.UreaderMatches.cancelTimeout("other mouseenter");

					_tpl.hide();

					//#hover
					$li_matches.removeClass("hover");

					
					// Enable tooltip (except Site Home page)

						var isSiteHomePage = $('body').hasClass("index_homepage");

						if (!isSiteHomePage){
							 var _data = $(_el).data("MatchTooltip");
										if (!_data) {
											$(_el).UreaderMatchTooltip(function() {
												$.UreaderMatches.timeout = _init_tooltip(_el, _tlpR);
											});
											return false;
										}
										$.UreaderMatches.timeout = _show_tooltip(_el, _data, _tlpR);
						}
				});
			});

			_tpl
			.mouseover(function() {
				$.UreaderMatches.cancelTimeout("tooltip hover");
			}).mouseleave(function() {
				$.UreaderMatches.cancelTimeout("tooltip mouseleave");
				_tpl.hide();
				//#hover
				$li_matches.removeClass("hover");
			});

			/*//DEBUG:*/
			$('.js-urMatches .session').mouseleave(function(ev) {
				//console.log("cancel");
				$.UreaderMatches.cancelTimeout("exit zone");
				var _t = ev.target;
				$.UreaderMatches.timeout = setTimeout(function() {
					//console.log(_t)
					_tpl.hide();
					//#hover
					$li_matches.removeClass("hover");
				}, 100);
			});

			_tpl.find(".close").click(function() {
				$.UreaderMatches.cancelTimeout("tooltip close");
				_tpl.hide();
				//#hover
				$li_matches.removeClass("hover");
				return false;
			});

			//DEBUG:$li_matches.eq(0).trigger("mouseenter");
		}
	};

	$.fn.UreaderMatchTooltip = function(callback) {
		var config = {
			library: '/syndication/ureader/feeds/tooltip/cup={cup}/season={season}/match={match}/_tooltip.json'
		};
		return this.each(function() {
			var that = this;

			try {
				var _arrid = this.id.split("_");
				var _idcup = _arrid[1];
				var _season = _arrid[2];
				var _match = _arrid[3];
				var _library = config.library
											.replace("{cup}", _idcup)
											.replace("{season}", _season)
											.replace("{match}", _match);
				//.replace("{folder}", config.folders[_idcup.toString()])

			} catch (e) {
				if (console && console.log) { console.log(e); }
				return false;
			}
			//var _test = setTimeout(function() {
			$.getJSON(_library, function(data) {
				//_build_tooltip();
				//_show();
				//console.log(data);
				if (data.newsid) {

					//$('a.disabled', that).click(function(ev) { ev.stopPropagation(); return false; }); //.css("cursor","default");

					var _urmhome = $(that).find(".urmhome");
					var _urmaway = $(that).find(".urmaway");
					var _urmstand = $(that).find(".urmstnd").attr("href");
					var _urmmatch = $(that).find(".urmmatch a").attr("href");
					var _urmpk = $(that).find(".urmpk").attr("href");
					var _urmhigh = $(that).find(".freehigh .mr");
					var _urmreplay = $(that).find(".video .mr");

					$.extend(data, {}, {
						teamhome: _urmhome.text(),
						teamhomel: _urmhome.attr("href"),
						teamaway: _urmaway.text(),
						teamawayl: _urmaway.attr("href"),
						standing: _urmstand,
						presskit: _urmpk,
						matchlink: _urmmatch,
						rplhtml: _urmreplay,
						hghhtml: _urmhigh,
						thumb_loaded: false
					});

				}

				$(that).data("MatchTooltip", data);

				//console.log("MATCHID >> ", $.UreaderMatches.id);
				//console.log("CHECK >> ", that.id);

				if (!$.UreaderMatches.timeout && $.UreaderMatches.id == that.id && callback)
					callback();
			});
			//}, 2000);
		});
	};
	$.fn.MatchesFixLineHeight = function() {
		return this.each(function() {
			var that = this;

			if ($(that).is("hf"))
				return;

			$(that).addClass("hf");

			$('.tn', that).each(function() {
				//console.log($(this).height());
				//console.log($(this).text());
				var _h = $(this).height();
				if (_h > 27) {
					$(this).css('lineHeight', '10px');
				}
				$(this).height(27);
			});

		});

	};

})(jQuery);
;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */

/*

Fork of: \js\core\apps\ureader\ureadermatches.source.js

Require: $.UreaderMatches
\js\ureader\matches.js

TEST:
/index_matchlist.html
/library/hp/matchlist/_includer.html

VIEWS:
\code\UReader\v3\MatchList\View\MatchListURIncluder.xslt
\code\UReader\v3\MatchList\View\MatchListURBySession.xslt

*/

(function ($, win, undefined) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var trace = d3.Trace;
  //var core = d3.core.getInstance();

  // Default configuration properties.
  //var defaults = {};

  /*
  * The skeleton object.
  *
  */
  p3.hpLiveCoverage = function (e, o) {

    /* ------------------------- */
    /* Variables */
    //var _this = this;
    //var _opt = $.extend(true, {}, defaults, o || {});  //options
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements
    var _cache = {};


    /* ------------------------- */
    /* Declaring private functions */
    var _dom, _ondata, _tabs, _legacy;

    /* ------------------------- */
    //Public Functions
    this.init = function () {

      _dom();


      _tabs();

      _legacy();

      //subscribe jsonplive.ondata event
      $(document).bind('jsonplive.ondata', _ondata);

      _ondata();

    };


    //cache dom elements
    _dom = function () {

      $de.panels = $dom.find('div.competition');
      $de.live = $dom.find('[data-live]');
      $de.handlers = $dom.find('.js-comp-hnd');
      //trace($de);
    };

    //manage trivial tabs show/hide logic and bind the click
    _tabs = function () {

      $de.handlers.each(function (n) {
        $(this).click(function () {
          $de.panels.hide();
          $de.panels.eq(n).show();

          $de.handlers.removeClass('selected');
          $(this).addClass('selected');

          return false;
        });
      });

    };

    //launch tooltip and other old stuffs
    _legacy = function () {
      //legacy code
      $.UreaderMatches.onReady();
    };

    _ondata = function () {

      function trn(word) {
        return window.Deltatre.Uefacom.MatchStatusDictionary.Translate[word];
      }

      function abbr(word) {
        return window.Deltatre.Uefacom.MatchStatusDictionary.Abbreviation[word];
      }

      function __score(o) {
        var sc;
        sc = o.State.Score.Home + '-' + o.State.Score.Away;
        if (o.State.Status == 0) sc = sc + __reasonwin(o);
        return sc;
      }

      function __reasonwin(o) {
        var rwElement = "";

        var s, rw, leg, scorea, scoreh, scoreagga, scoreaggh, scorepenh, scorepena, winteam;

        s = o.State.Status;
        rw = o.State.ReasonWin;
        leg = o.Match.Leg;
        winteam = o.State.Winner;


        scoreagga = o.State.Aggregate.Away;
        scoreaggh = o.State.Aggregate.Home;
        scorepena = o.State.Penalties.Away;
        scorepenh = o.State.Penalties.Home;


        var txt = "<abbr title='#1'>#2</abbr>";

        if (rw == 2 || rw == 5) {
          rwElement += txt.replace("#1", trn("mdaet")).replace("#2", abbr("mdaet"));
          if (leg == 2) {
            rwElement += ", ";
          }
        }
        if (rw == 6 || rw == 7) {
          rwElement += txt.replace("#1", trn("mdoag")).replace("#2", abbr("mdoag"));
          if (leg == 2) {
            rwElement += ", ";
          }
        }
        if (rw == 11) {
          rwElement += txt.replace("#1", trn("coin")).replace("#2", abbr("coin"));
        }
        if (scorepena.toString() != "" && scorepena > -1) {
          var p = scorepenh + "-" + scorepena + abbr("mdaetps");
          rwElement += txt.replace("#1", trn("mdaetps")).replace("#2", p);
          if (leg == 2) {
            rwElement += ", ";
          }
        }

        if (leg == 2) {
          rwElement += txt.replace("#1", trn("aggregate")).replace("#2", abbr("aggregate"));
          rwElement += ": " + scoreaggh + "-" + scoreagga;
        }

        if (rwElement != "") {
          rwElement = '<span class="rw">(' + rwElement + ')</span>';
        }

        return rwElement;
      }


      var _data = p3.jsonplive.prototype.data;
      if (_data) {
        //matches live
        if ($de.live.length > 0) {
          $.each(_data.m, function (i, v) {
            //trace(v.idMatch, $de.live.filter('[data-live="' + v.idMatch + '"]'));
            if (_cache[v.idMatch] === undefined || (_cache[v.idMatch] !== undefined && _cache[v.idMatch] !== v.s)) {
              _cache[v.idMatch] = v.s;

              $de.live.filter('[data-live="' + v.idMatch + '"]').toggleClass('live', (v.s === "3"));
              $de.live.filter('[data-live="' + v.idMatch + '"]').find(".urm-m-score").toggleClass("urm-m-play", (v.s === "3"))

              if (v.s != "0" && v.s === "3") {

                var _liveLnk = $de.live.filter('[data-live="' + v.idMatch + '"]').find(".urm-m-score").attr("data-url-live");
                var _liveTxt = $de.live.filter('[data-live="' + v.idMatch + '"]').find(".urm-m-score").attr("data-word-live");
                $de.live.filter('[data-live="' + v.idMatch + '"]').find("a.sc").text(_liveTxt);
                $de.live.filter('[data-live="' + v.idMatch + '"]').find("a.sc").attr("href", _liveLnk);

              }
              else if (v.s === "0") {

                var _m = $de.live.filter('.urmatch[data-live="' + v.idMatch + '"]');

                var _year = _m.attr("data-year");
                var _month = _m.attr("data-month");
                var _day = _m.attr("data-day");

                var _url = "/live/match-centre/livescores/year=" + _year + "/month=" + _month + "/day=" + _day + "/match=" + v.idMatch + "/livescore.json?t=" + new Date().getTime();
                var _postLnk = $de.live.filter('[data-live="' + v.idMatch + '"]').find(".urm-m-score").attr("data-url-post");


                _m.find("a.sc").attr("href", _postLnk);


                $.ajax({
                  url: _url,
                  dataType: 'json',
                  success: function (data) {
                    var _s = data.State.Status;
                    var _r = data.State.Report;
                    var _score = data.State.Score;
                    var _leg = data.Match.Leg;

                    _m.find("a.sc").html(__score(data));
                  },
                  error: function (xhr, ajaxOptions, thrownError) {
                    //onEndRequest();

                  }
                });

                /**

                var _postLnk = $de.live.filter('[data-live="' + v.idMatch + '"]').find(".urm-m-score").attr("data-url-post");
                var _postTxt = $de.live.filter('[data-live="' + v.idMatch + '"]').find(".urm-m-score").attr("data-word-post");
                $de.live.filter('[data-live="' + v.idMatch + '"]').find("a.sc").text(_postTxt);
                $de.live.filter('[data-live="' + v.idMatch + '"]').find("a.sc").attr("href", _postLnk);

                
                **/



              }
              /* abandoned , cancelled , suspended , postponed */
              else if ((v.s === "26") || (v.s === "8") ||  (v.s === "4") ||  (v.s === "7") ){
                var _m = $de.live.filter('li[data-live="' + v.idMatch + '"]');
                var s = window.Deltatre.Uefacom.MatchStatusDictionary.Status[v.s];
                var sAbbr = window.Deltatre.Uefacom.MatchStatusDictionary.Abbreviation[v.s];
                var txt = "<abbr title='#1'>#2</abbr>";
                _m.find("a.sc").html(txt.replace("#1",s).replace("#2",sAbbr));
              }
            }

          });
        }
      }
    };

  };


} (jQuery, window));

;/* exclude for JSLint parsing */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */
/*global window, jQuery */

(function ($, win, undefined) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var trace = d3.Trace;
  //var core = d3.core.getInstance();

  // Default configuration properties.
  var defaults = {
    link: {
      selector: '.js-allmatches',
      livelabel: 'See all matches',
      endlabel: 'See all matches'
    },
    title: {
      selector: '.js-todaysmatches',
      livelabel: 'Today\'s matches:',
      endlabel: 'Today\'s matches:'
    }
  };

  /*
  * The skeleton object.
  *
  */
  p3.todaysmatches = function (e, o) {

    /* ------------------------- */
    /* Variables */
    var _this = this;
    var _opt = $.extend(true, {}, defaults, o || {});  //options
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements

    var _uefaCompetitionCups = [1, 3, 5, 9, 13, 14, 17, 18, 22, 23, 24, 25, 27, 28, 38, 39, 101, 2008];
    var _domesticCups = [1026, 1027, 1028, 1031, 1032, 1035, 1038, 1039, 1042, 1046, 1048, 1049, 1050, 1053, 1054, 1055, 1056, 1062, 1069];

    /* ------------------------- */
    /* Declaring private functions */
    var _bind, _dom, _ondata;

    /* ------------------------- */
    //Public Functions
    this.init = function () {

      _dom();

      _bind();

      //subscribe jsonplive.ondata event
      $(document).bind('jsonplive.ondata', _ondata);

    };


    /* ------------------------- */
    //Private Functions
    _dom = function () {
      $de.link = $dom.find(_opt.link.selector);
      $de.title = $dom.find(_opt.title.selector);
    };

    _bind = function () {
      $dom.find('.hp-close-button').click(function () {
        $dom.animate({ "opacity": 0 }, 1000, function () {
          $dom.hide();
        });

      });

    };


    _ondata = function () {

      var _data = p3.jsonplive.prototype.data;

      if (_data) {

        var _cache = {};
        var _allMatchesFinished = true;

        $.each(_data.m, function (i, v) {
          var _islive;
          var _isliveDomestic;



          if (v.s != "2") {
            _allMatchesFinished = false;
          }

          if (($.inArray(v.cup, _uefaCompetitionCups) > -1)) {
            _islive = v.s === "3";

            //trace("mIsLive (" + v.cup + ")", _islive);

            if (_cache[v.cup] === true) {
              return true; //continue cycle
            } else {
              //set cache
              _cache[v.cup] = _islive;
            }

          } else {
            if (($.inArray(v.cup, _domesticCups) > -1)) {
              _isliveDomestic = v.s === "3";

              //trace("mIsLive (" + v.cup + ")", _isliveDomestic);

              if (_cache['domestic'] === true) {
                return true; //continue cycle
              } else {
                //set cache
                _cache['domestic'] = _isliveDomestic;
              }

            }
          }


        });

        $.each(_cache, function (i, v) {
          $dom.find(".js-cup-" + i).toggleClass('live', v);
        });

        /*check for Mobile Version - highlighting Matches label */
        if ($dom.find(".hp-competitions-group li.live").size() > 0) $dom.find(".js-todaysmatches-count").addClass('live');


        $de.title.html(_allMatchesFinished ? _opt.title.endLabel : _opt.title.liveLabel);
        $de.link.html(_allMatchesFinished ? _opt.link.endLabel : _opt.link.liveLabel);

      }

    };


  };


} (jQuery, window));
;/// <reference path="../user-management/user.source.js" />
/// <reference path="../user-management/endava.source.es6.js" />
/*global window, jQuery, User */

(function ($, win) {
  'use strict';

  //Declare namespaces
  win.Deltatre = win.Deltatre || {};
  win.Deltatre.plugins = win.Deltatre.plugins || {};

  //shortcut
  var d3 = win.Deltatre || {},
      p3 = d3.plugins || {},
      trace = d3.Trace || function () { };
  //var core = d3.core.getInstance();

  // Default configuration properties.
  var defaults = {
    returnUrl: win.location.href
  };

  /*
	* The loginpanel object.
	*/
  p3.loginpanel = function (e, o) {
    /* ------------------------- */
    /* Variables */
    var _opt = $.extend(true, {}, defaults, o || {});  //options
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements
    var _s = this;

    /* ------------------------- */
    //Public Functions
    this.init = function () {
      var u = new User();
      if (u.isLogged() && location.pathname && location.pathname.toLowerCase().indexOf('/login') > -1) {
        if (win.opener) {
          try {
            var origin = window.location.search.split('=')[1];
            win.opener.postMessage({ key: 'userLogged' }, origin);
          } catch (e) {
            trace(e);
          }
          win.close();
        } else
          location.href = location.origin;
      }

      // Cache dom elements
      $de.form = $('.js-std-login-form', $dom);
      $de.email = $('#uefa-login-email', $de.form);
      $de.pwd = $('#uefa-login-password', $de.form);
      $de.keeplogin = $('#uefa-login-keep', $de.form);
      $de.errLabel = $('#login-error-label', $dom);

      _s.initButtons();
      win.onpopstate = function () {
        _s.initButtons();
      }
    };

    /* ------------------------- */
    //Private Functions

    this.initButtons = function () {
      var domain = d3.loginHandler.url;
      var returnurl = d3.loginHandler.getReturnUrl(win.location.href);
      var popupReturnurl = d3.loginHandler.getReturnUrl(_opt.returnUrl + '?origin=' + win.location.origin + "#closeandreload");
      var popupStyle = "status=0, menubar=0, toolbar=0, location=0, scrollbars=0, resizable=0";
      var popupName = "login_popup";
      var isPrd = location.hostname.indexOf('.stg.irt.uefa.') === -1 && location.hostname.indexOf('.stg.infra.uefa.') === -1 && location.hostname.indexOf('localhost') === -1;
      var lang = $('html').attr('lang') || 'en';
      lang = lang === 'en' ? 'www' : lang;
      var loginUrl = (isPrd ? 'https://' : 'http://') + lang + (isPrd ? '' : '.stg.infra') + '.uefa.com/login/index.html?origin=' + win.location.origin;
      var origin = window.location.search.split('=')[1];

      // Init social buttons
      $('.js-std-login-social-link', $de.form).on('click', function (e) {
        e.preventDefault();
        var _li = $(this);
        _s.openPopup(domain + '/Account/LoginWith' + _li.data('service') + '?returnUrl=' + (!isPrd ? "http:" : "") +popupReturnurl, popupName, 600, 600, popupStyle);
        if (!!window.MSInputMethodContext && !!document.documentMode) {  //ie 11 workaround refresh logout
          setTimeout(function () {
            window.postMessage({ key: 'userLogged' }, window.location.origin);
          }, 2000);
        }
        return false;
      });

      // Init login button
      $('#uefa-login-open,.js-uefa-login-open', $de.form).on('click', function (e) {
        e.preventDefault(); // stop form submit
        _s.openPopup(loginUrl, popupName, 400, 600, popupStyle);
        if (!!window.MSInputMethodContext && !!document.documentMode) {  //ie 11 workaround refresh logout
          setTimeout(function () {
            window.postMessage({ key: 'userLogged' }, window.location.origin);
          }, 2000);
        }
        return false; // stop form submit
      });

      // Init register button
      $('#uefa-login-register,.js-uefa-login-register', $de.form).attr('href', domain + '/Account/SignUp?returnUrl=' + encodeURI(returnurl));

      $('#uefa-login-forgot,.js-uefa-login-forgot', $de.form).on('click', function (e) {
        e.preventDefault();

        if (win.opener) {
          win.opener.postMessage({ key: 'forgettenPassword' }, origin);
          win.close();
        }

        return false;
      });

      d3.eventBus.on('forgettenPassword', function () {
        win.location.href = domain + '/ForgottenPassword?returnUrl=' + encodeURI(win.location.href);
      });

      // Inside the popup
      // Init handlers
      $de.form.on('submit', function (e) {
        e.preventDefault(); // stop form submit

        _s.submitLogin();

        return false; // stop form submit
      });
      $de.email.on('focus change', function () {
        $(this).parent().removeClass('error');
      });
      $de.pwd.on('focus change', function () {
        $(this).parent().removeClass('error');
      });
    };

    // Submit login
    this.submitLogin = function () {
      _s.onLoginError();
      if (_s.validateFields([{ field: $de.email, type: 'requiredEmail' }, { field: $de.pwd, type: 'required' }])) {
        d3.loginHandler.doLogin($de.email.val().replace(/\s/g, ''), $de.pwd.val().replace(/\s/g, ''), $de.keeplogin.prop('checked'), _s.onLoginSuccess, _s.onLoginError);
      }
    };
    // Validate a form field
    this.validateFields = function (fields) {
      var result = true;
      for (var i = 0; i < fields.length; i++) {
        switch (fields[i].type) {
          case 'required':
            if (fields[i].field.val() !== '') {
              fields[i].field.parents('[data-js="login-input"]').removeClass('has-error');
            } else {
              fields[i].field.parents('[data-js="login-input"]').addClass('has-error');
              result = false;
            }
            break;
          case 'requiredEmail':
            var regexp = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;
            if (regexp.test(fields[i].field.val().replace(/\s/g, '')) === false) {
              fields[i].field.parents('[data-js="login-input"]').addClass("has-error");
              result = false;
            } else {
              fields[i].field.parents('[data-js="login-input"]').removeClass("has-error");
            }
            break;
          default:
            console.log('No type matched');
            break;
        }
      }
      return result;
    };

    this.onLoginError = function (error) {
      if (error) trace(error);
      if (error && error.loginStatus) {
        //var message = decodeURI(error.message);
        //$de.errLabel.text(message);
        $de.errLabel.show();
      } else {
        //$de.errLabel.text('');
        $de.errLabel.hide();
      }
    };

    this.onLoginSuccess = function () {
      if (win.opener) {
        try {
          var origin = window.location.search.split('=')[1];
          win.opener.postMessage({ key: 'userLogged' }, origin);
        } catch (e) {
          trace(e);
        }
      }

      win.close();
    };

    this.openPopup = function (url, title, w, h, style) {
      // Fixes dual-screen position                         Most browsers      Firefox
      var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;
      var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;

      var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
      var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;

      var left = ((width / 2) - (w / 2)) + dualScreenLeft;
      var top = ((height / 2) - (h / 2)) + dualScreenTop;
      var newWindow = window.open(url, title, style + ', width=' + w + ', height=' + h + ', top=' + top + ', left=' + left);

      // Puts focus on the newWindow
      if (window.focus) {
        newWindow.focus();
      }

      return newWindow;
    }
  };

  if (location.hash && location.hash.indexOf('#closeandreload') > -1) {
    if (win.opener) {
      try {
        var origin = window.location.search.split('=')[1];
        win.opener.postMessage({ key: 'userLogged' }, origin);
        if (!!window.MSInputMethodContext && !!document.documentMode) {  //ie 11 workaround refresh logout
          window.postMessage({ key: 'userLogged' },origin);
        }
      } catch (e) {
        trace(e);
      }
    }

    win.close();
  }
})(jQuery, window);
;/* exclude for JSLint parsing */
/*jslint unparam: true, nomen: true, vars: true, white: true, todo: true, plusplus: true */
/*global window, jQuery */

(function ($, win, undefined) {

  'use strict';

  //shortcut
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var trace = d3.Trace;
  //var core = d3.core.getInstance();

  // Default configuration properties.
  var defaults = {
    version: 1,
    handlersDelay: 100,
    stickyThreshold: 100
  };

  /*
	* The responsivemenu object.
  * This plugin handles the responsiveness of Level 2 navigation, moving items in and out of the "more" dropdown when necessary.
	*/
  p3.responsivemenu = function (e, o) {

    /* ------------------------- */
    /* Variables */
    var _this = this;
    var _opt = $.extend(true, {}, defaults, o || {});  //options
    var $dom = e; //the jquery element we are working with
    var $de = {}; //dom elements
    var $win = $(win);
    var _maxItems = 0; //Maximum items outside of "more" dropdown
    var _stickyHeight = 0;

    /* ------------------------- */
    /* Declaring private functions */
    var _throttle, _resizeMenu, _moveDropdownIn, _moveDropdownOut, _toggleSticky

    /* ------------------------- */
    //Public Functions
    this.init = function () {
      // Cache dom elements
      $de.nav = $dom.find('.nav');
      $de.topItems = $de.nav.find('>li').not('.moremenu');
      $de.moreBtn = $dom.find('.moremenu');
      $de.moreMenu = $de.moreBtn.find('.dropdown-menu');
      $de.moreItems = $de.moreMenu.find('>li').not('.js-subitem, .dropdown-header');

      // Init variables
      _maxItems = $de.topItems.length;

      // Init event handlers
      // Load event is listened to resize menu at startup
      $win.on('load.responsivemenu orientationchange.responsivemenu resize.responsivemenu affixed.bs.affix affixed-top.bs.affix', _throttle(_resizeMenu, _opt.handlersDelay));
      // Stickyness!
      $win.on('load.stickybar scroll.stickybar', _throttle(_toggleSticky, _opt.handlersDelay));
    };

    /* ------------------------- */
    //Private Functions
    _throttle = function (fn, threshhold, forceDelay) {
      threshhold || (threshhold = _opt.handlersDelay);
      var last,
        deferTimer;
      return function () {
        var context = this;

        var now = +new Date,
          args = arguments;
        if (forceDelay) {
          last = now; // Force delay on first execution
        }
        if (last && now < last + threshhold) {
          // hold on to it
          clearTimeout(deferTimer);
          deferTimer = setTimeout(function () {
            last = now;
            fn.apply(context, args);
          }, threshhold);
        } else {
          last = now;
          fn.apply(context, args);
        }
      };
    };

    _resizeMenu = function () {
      // Update cached items
      $de.topItems = $de.nav.find('>li').not('.moremenu');
      $de.moreItems = $de.moreMenu.find('>li').not('.js-subitem, .dropdown-header');
      // calculate width of container
      var _cW = $de.nav.outerWidth();
      // calculate width of visible items
      var _iW = $de.moreBtn.is(':visible') ? $de.moreBtn.outerWidth() : 0;
      $de.topItems.each(function () {
        _iW += $(this).outerWidth();
      });

      var _nW = 0; // new width of visible items
      var _last = 0; // index of last item that can fit in the container
      if (_iW > _cW) {
        // if items don't fit in the container, move some in the dropdown
        _nW = $de.moreBtn.outerWidth();
        $de.topItems.each(function (i, el) {
          _nW += $(el).outerWidth();
          if (_nW > _cW) {
            // new width exceedes container width, stop at the previous index
            _last = i - 1;
            return false;
          }
        });
        // move items that don't fit in the contaienr to the dropdown menu
        $de.topItems.filter(function (i) {
          return i > _last;
        }).reverse().each(function () {
          var $el = $(this);
          if ($el.hasClass('dropdown')) {
            _moveDropdownIn($el);
          } else {
            $el.prependTo($de.moreMenu);
          }
        });
        $de.moreBtn.show();
      } else {
        // if there's room in the container and visible items are less then _maxItems, move some outside of the dropdown
        var _tL = $de.topItems.length;
        $de.moreItems.each(function (i, el) {
          if (_tL < _maxItems) {
            var $el = $(el);
            // move first dropdown item outside
            if ($el.hasClass('js-was-dropdown')) {
              _moveDropdownOut($el);
            } else {
              $el.insertBefore($de.moreBtn);
            }
            _nW = _iW + $el.outerWidth();
            if (_nW > _cW) {
              // new width exceedes container width, move back last one and stop
              if ($el.hasClass('dropdown')) {
                _moveDropdownIn($el);
              } else {
                $el.prependTo($de.moreMenu);
              }
              return false;
            } else {
              _tL++;
              _iW = _nW;
            }

          } else {
            // visible items == _maxItems, stop
            return false;
          }
        });
        if ($de.moreMenu.children().length === 0) {
          $de.moreBtn.hide();
        }
      }
    };

    _moveDropdownIn = function ($dd) {
      // Store $dd name
      var _parentName = $dd.data('title');
      // Remove $dd's dropdown classes and data (li and a)
      $dd.removeClass().addClass('js-was-dropdown');
      $dd.find('>a').removeClass().removeAttr('role').removeAttr('data-toggle').removeData('toggle');
      // Detach $dd's children, remove ul
      var $submenu = $dd.find('.dropdown-menu');
      var $subitems = $submenu.find('>li').detach();
      $submenu.remove();
      // Prepend $dd to $de.moreMenu
      $dd.prependTo($de.moreMenu).css('display', 'none');
      // Insert $dd's children in $de.moreMenu after $dd, add a span with "<$dd name>\" inside each one and as a data attribute
      $subitems.reverse().each(function () {
        $(this).addClass('js-subitem').attr('data-parent', _parentName).insertAfter($dd); //.find('>a').prepend('<span class="dropdown-parent">' + _parentName + '\\</span>');
      });
      // Insert header for $dd's children in $de.moreMenu
      $('<li class="dropdown-header"></li>').attr('data-parent', _parentName).text(_parentName).insertAfter($dd);
    };
    _moveDropdownOut = function ($dd) {
      var _parentName = $dd.data('title');
      // Find $dd's children inside $de.moreMenu
      var $subitems = $de.moreMenu.find('.js-subitem[data-parent="' + _parentName + '"]');
      // Remove parent name from $dd's children
      //$subitems.find('.dropdown-parent').remove();
      // Remove header for $dd's children
      $de.moreMenu.find('.dropdown-header[data-parent="' + _parentName + '"]').remove();
      // Restore $dd's dropdown classes and data (li and a), 
      $dd.removeClass().addClass('dropdown').removeAttr('style');
      $dd.find('>a').attr({
        role: 'button',
        'data-toggle': 'dropdown'
      }).data('toggle', 'dropdown').addClass('doprdown-toggle');
      // Restore ul inside $dd and move $dd's children inside it
      var $submenu = $('<ul class="dropdown-menu"></ul>').appendTo($dd);
      $subitems.appendTo($submenu);
      // Move $dd outside of $de.moreMenu
      $dd.insertBefore($de.moreBtn);
    };

    _toggleSticky = function () {
      if ($win.scrollTop() >= _opt.stickyThreshold) {
        $dom.addClass('affix').removeClass('affix-top');
        // @TODO: fix "height jump" glitch
        $win.trigger('affixed.bs.affix');
      } else {
        $dom.addClass('affix-top').removeClass('affix');
        // @TODO: fix "height jump" glitch
        $win.trigger('affixed-top.bs.affix');
      }
    };

    return _this;
  };

  // Reverse - mini jQuery plugin :)
  jQuery.fn.reverse = Array.prototype.reverse;

}(jQuery, window));
;(function () {
	// Stop from running again, if accidently included more than once.
	if (window.hasCookieConsent) return;
	window.hasCookieConsent = true;

	/*
   Constants
   */

	// Client variable which may be present containing options to override with
	var OPTIONS_VARIABLE = 'cookieconsent_options';

	// Change cookie consent options on the fly.
	var OPTIONS_UPDATER = 'update_cookieconsent_options';

	// Name of cookie to be set when dismissed
	var DISMISSED_COOKIE = 'cookieconsent_dismissed';

	// The path to built in themes
	// Note: Directly linking to a version on the CDN like this is horrible, but it's less horrible than people downloading the code
	// then discovering that their CSS bucket disappeared
	var THEME_BUCKET_PATH = '//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/1.0.10/';

	// No point going further if they've already dismissed.
	if (document.cookie.indexOf(DISMISSED_COOKIE) > -1 || (window.navigator && window.navigator.CookiesOK)) {
		return;
	}

	// IE8...
	if(typeof String.prototype.trim !== 'function') {
		String.prototype.trim = function() {
			return this.replace(/^\s+|\s+$/g, '');
		};
	}

	/*
   Helper methods
   */
	var Util = {
		isArray: function (obj) {
			var proto = Object.prototype.toString.call(obj);
			return proto == '[object Array]';
		},

		isObject: function (obj) {
			return Object.prototype.toString.call(obj) == '[object Object]';
		},

		each: function (arr, callback, /* optional: */context, force) {
			if (Util.isObject(arr) && !force) {
				for (var key in arr) {
					if (arr.hasOwnProperty(key)) {
						callback.call(context, arr[key], key, arr);
					}
				}
			} else {
				for (var i = 0, ii = arr.length; i < ii; i++) {
					callback.call(context, arr[i], i, arr);
				}
			}
		},

		merge: function (obj1, obj2) {
			if (!obj1) return;
			Util.each(obj2, function (val, key) {
				if (Util.isObject(val) && Util.isObject(obj1[key])) {
					Util.merge(obj1[key], val);
				} else {
					obj1[key] = val;
				}
			})
		},

		bind: function (func, context) {
			return function () {
				return func.apply(context, arguments);
			};
		},

		/*
     find a property based on a . separated path.
     i.e. queryObject({details: {name: 'Adam'}}, 'details.name') // -> 'Adam'
     returns null if not found
     */
		queryObject: function (object, query) {
			var queryPart;
			var i = 0;
			var head = object;
			query = query.split('.');
			while ( (queryPart = query[i++]) && head.hasOwnProperty(queryPart) && (head = head[queryPart]) )  {
				if (i === query.length) return head;
			}
			return null;
		},

		setCookie: function (name, value, expiryDays, domain, path) {
			expiryDays = expiryDays || 365;

			var exdate = new Date();
			exdate.setDate(exdate.getDate() + expiryDays);

			var cookie = [
        name + '=' + value,
        'expires=' + exdate.toUTCString(),
        'path=' + path || '/'
			];

			if (domain) {
				cookie.push(
          'domain=' + domain
        );
			}

			document.cookie = cookie.join(';');
		},

		addEventListener: function (el, event, eventListener) {
			if (el.addEventListener) {
				el.addEventListener(event, eventListener);
			} else {
				el.attachEvent('on' + event, eventListener);
			}
		}
	};

	var DomBuilder = (function () {
		/*
     The attribute we store events in.
     */
		var eventAttribute = 'data-cc-event';
		var conditionAttribute = 'data-cc-if';

		/*
     Shim to make addEventListener work correctly with IE.
     */
		var addEventListener = function (el, event, eventListener) {
			// Add multiple event listeners at once if array is passed.
			if (Util.isArray(event)) {
				return Util.each(event, function (ev) {
					addEventListener(el, ev, eventListener);
				});
			}

			if (el.addEventListener) {
				el.addEventListener(event, eventListener);
			} else {
				el.attachEvent('on' + event, eventListener);
			}
		};

		/*
     Replace {{variable.name}} with it's property on the scope
     Also supports {{variable.name || another.name || 'string'}}
     */
		var insertReplacements = function (htmlStr, scope) {
			return htmlStr.replace(/\{\{(.*?)\}\}/g, function (_match, sub) {
				var tokens = sub.split('||');
				var value, token;
				while (token = tokens.shift()) {
					token = token.trim();

					// If string
					if (token[0] === '"') return token.slice(1, token.length - 1);

					// If query matches
					value =  Util.queryObject(scope, token);

					if (value) return value;
				}

				return '';
			});
		};

		/*
     Turn a string of html into DOM
     */
		var buildDom = function (htmlStr) {
			var container = document.createElement('div');
			container.innerHTML = htmlStr;
			return container.children[0];
		};

		var applyToElementsWithAttribute = function (dom, attribute, func) {
			var els = dom.parentNode.querySelectorAll('[' + attribute + ']');
			Util.each(els, function (element) {
				var attributeVal = element.getAttribute(attribute);
				func(element, attributeVal);
			}, window, true);
		};

		/*
     Parse event attributes in dom and set listeners to their matching scope methods
     */
		var applyEvents = function (dom, scope) {
			applyToElementsWithAttribute(dom, eventAttribute, function (element, attributeVal) {
				var parts = attributeVal.split(':');
				var listener = Util.queryObject(scope, parts[1]);
				addEventListener(element, parts[0], Util.bind(listener, scope));
			});
		};

		var applyConditionals = function (dom, scope) {
			applyToElementsWithAttribute(dom, conditionAttribute, function (element, attributeVal) {
				var value = Util.queryObject(scope, attributeVal);
				if (!value) {
					element.parentNode.removeChild(element);
				}
			});
		};

		return {
			build: function (htmlStr, scope) {
				if (Util.isArray(htmlStr)) htmlStr = htmlStr.join('');

				htmlStr = insertReplacements(htmlStr, scope);
				var dom = buildDom(htmlStr);
				applyEvents(dom, scope);
				applyConditionals(dom, scope);

				return dom;
			}
		};
	})();


	/*
   Plugin
   */
	var cookieconsent = {
		options: {
			message: 'This website uses cookies to ensure you get the best experience on our website. ',
			dismiss: 'Got it!',
			learnMore: 'More info',
			link: null,
			target: '_self',
			container: null, // selector
			theme: 'light-floating',
			domain: null, // default to current domain.
			path: '/', 
			expiryDays: 365,
			markup: [
        '<div class="cc_banner-wrapper {{containerClasses}}">',
        '<div class="cc_banner cc_container cc_container--open">',
        '<a href="#null" data-cc-event="click:dismiss" target="_blank" class="cc_btn cc_btn_accept_all">{{options.dismiss}}</a>',

        //'<p class="cc_message">{{options.message}} <a data-cc-if="options.link" target="{{ options.target }}" class="cc_more_info" href="{{options.link || "#null"}}">{{options.learnMore}}</a></p>',
				'<p class="cc_message">{{options.message}}</p>',

        '<a class="cc_logo" target="_blank" href="http://silktide.com/cookieconsent">Cookie Consent plugin for the EU cookie law</a>',
        '</div>',
        '</div>'
			]
		},

		init: function () {
			var options = window[OPTIONS_VARIABLE];
			if (options) this.setOptions(options);

			this.setContainer();

			// Calls render when theme is loaded.
			if (this.options.theme) {
				this.loadTheme(this.render);
			} else {
				this.render();
			}
		},

		setOptionsOnTheFly: function (options) {
			this.setOptions(options);
			this.render();
		},

		setOptions: function (options) {
			Util.merge(this.options, options);
		},

		setContainer: function () {
			if (this.options.container) {
				this.container = document.querySelector(this.options.container);
			} else {
				this.container = document.body;
			}

			// Add class to container classes so we can specify css for IE8 only.
			this.containerClasses = '';
			if (navigator.appVersion.indexOf('MSIE 8') > -1) {
				this.containerClasses += ' cc_ie8'
			}
		},

		loadTheme: function (callback) {
			var theme = this.options.theme;

			// If theme is specified by name
			if (theme.indexOf('.css') === -1) {
				theme = THEME_BUCKET_PATH + theme + '.css';
			}

			var link = document.createElement('link');
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = theme;

			var loaded = false;
			link.onload = Util.bind(function () {
				if (!loaded && callback) {
					callback.call(this);
					loaded = true;
				}
			}, this);

			document.getElementsByTagName("head")[0].appendChild(link);
		},

		render: function () {
			// remove current element (if we've already rendered)
			if (this.element && this.element.parentNode) {
				this.element.parentNode.removeChild(this.element);
				delete this.element;
			}

			this.element = DomBuilder.build(this.options.markup, this);
			if (!this.container.firstChild) {
				this.container.appendChild(this.element);
			} else {
				this.container.insertBefore(this.element, this.container.firstChild);
			}
		},

		dismiss: function (evt) {
			evt.preventDefault && evt.preventDefault();
			evt.returnValue = false;
			this.setDismissedCookie();
			this.container.removeChild(this.element);
		},

		setDismissedCookie: function () {
			Util.setCookie(DISMISSED_COOKIE, 'yes', this.options.expiryDays, this.options.domain, this.options.path);
		}
	};

	var init;
	var initialized = false;
	(init = function () {
		if (!initialized && document.readyState == 'complete') {
			cookieconsent.init();
			initialized = true;
			window[OPTIONS_UPDATER] = Util.bind(cookieconsent.setOptionsOnTheFly, cookieconsent);
		}
	})();

	Util.addEventListener(document, 'readystatechange', init);

})();

;/* exclude for JSLint parsing */
/*global window, document, jQuery, deltatre, Image */
/*jslint unparam: true, nomen: true, vars: true, white: true, plusplus: true */

(function ($, win, undefined) {

  'use strict';

  //shortcuts
  var $win = $(win);
  var d3 = win.Deltatre;
  var trace = d3.Trace;
  var core = d3.core.getInstance();

  //istances
  d3.lazyload = 0;

  //custom simple plugin in order to force appear of lazy images
  $.fn.lazyImage = function (opt) {
    var _t = this, _opt = opt || { animate: false };
    return this.each(function () {
      if (_opt.animate) {
        var $this = $(this).css({ "opacity": 0 });
        var _src = $this.attr('data-src');

        var _img = new Image();
        $(_img).bind("load", function () {

          $this
			    .attr("src", _src)
			    .animate({ "opacity": 1.0 })
			    .removeClass(_t.selector.replace('.', ''));

        });
        _img.src = _src;
      } else {
        $(this).attr("src", $(this).attr('data-src')).removeClass(_t.selector.replace('.', ''));
      }
    });
  };


  $.fn.lazyload = function (options) {

    var D3ID = ++d3.lazyload;

    var elements = this;
    var $container;
    var settings = {
      threshold: 0,
      failure_limit: 0,
      event: "scroll.lazyload",
      effect: "show",
      container: window,
      data_attribute: "src",
      skip_invisible: true,
      appear: null,
      load: null
    };

    function update() {
      var counter = 0;
      //trace("Lazyload update " + D3ID, elements.length, elements.eq(0));

      //PATCH
      if (elements.length === 0) {
        $container.unbind(settings.event + D3ID);
        $win.unbind(".lazyload" + D3ID);
        $('body').unbind(".lazyload" + D3ID);
        $(document).unbind(".lazyload" + D3ID);
      }

      elements.each(function () {
        var $this = $(this);
        //PATCH:
        if (!$this.is(".d3-plugin-lazy") && settings.skip_invisible && !$this.is(":visible")) {
          return;
        }
        if ($.abovethetop(this, settings) || $.leftofbegin(this, settings)) {
          /* Nothing. */
          trace("$.fn.lazyload - nothing to do");
        } else if (!$.belowthefold(this, settings) && !$.rightoffold(this, settings)) {
          $this.trigger("appear");
          /* if we found an image we'll load, reset the counter */
          counter = 0;
        } else {
          if (++counter > settings.failure_limit) {
            return false;
          }
        }
      });

    }

    if (options) {
      /* Maintain BC for a couple of versions. */
      if (undefined !== options.failurelimit) {
        options.failure_limit = options.failurelimit;
        delete options.failurelimit;
      }
      if (undefined !== options.effectspeed) {
        options.effect_speed = options.effectspeed;
        delete options.effectspeed;
      }

      $.extend(settings, options);
    }

    /* Cache container as jQuery as object. */
    $container = (settings.container === undefined ||
                      settings.container === window) ? $win : $(settings.container);

    /* Fire one scroll event per scroll. Not one scroll event per image. */
    if (0 === settings.event.indexOf("scroll")) {
      $container.bind(settings.event + D3ID, function () {
        return update();
      });
    }


    this.each(function () {
      var self = this;

      var $self = $(self);

      self.loaded = false;

      /* When appear is triggered load original image. */

      $self.one("appear", function () {

        //trace("APPEAR", this);
        var elements_left;

        if (!this.loaded) {

          if (self.tagName.toLowerCase() === 'img') {

            if (settings.appear) {
              elements_left = elements.length;
              settings.appear.call(self, elements_left, settings);
            }

            $("<img />")
            .bind("load", function () {
              $self
              .attr("src", $self.data(settings.data_attribute))
              .animate({ opacity: 1 }, settings.effect_speed); //#CUSTOM was : .hide().[settings.effect](settings.effect_speed); //
              self.loaded = true;

              /* Remove image from array so it is not looped next time. */
              var temp = $.grep(elements, function (element) {
                return !element.loaded;
              });
              elements = $(temp);

              if (settings.load) {
                elements_left = elements.length;
                settings.load.call(self, elements_left, settings);
              }

              //PATCH:events with namespace
              $self.unbind(settings.event + D3ID);

              //TRIGGER ALL IMAGES LOADED FOR LIVEBLOG
              if ($('img.js-lazy').filter(function() {return $(this).attr("src") !== $(this).attr("data-src");}).size() == 0) {
                $(document).trigger("allimagesloaded");
              }
            })
            .attr("src", $self.data(settings.data_attribute));
          }

          else if (self.tagName.toLowerCase() === 'iframe') {
            self.loaded = true;
            $self.attr("src", $self.data(settings.data_attribute));
          }

          else {

            core.launchPlugin($self);

            /* Remove plugin from array so it is not looped next time. */
            elements = elements.not($self);

            $self.unbind(settings.event + D3ID);
          }
        }
      });

      /* When wanted event is triggered load original image */
      /* by triggering appear.                              */
      if (0 !== settings.event.indexOf("scroll")) {
        $self.bind(settings.event, function () {
          if (!self.loaded) {
            $self.trigger("appear");
          }
        });
      }
    });

    /* Check if something appears when window is resized. */
    //PATCH: NAMESPACE
    $win
    .bind("resize.lazyload" + D3ID, function () {
      update(); //event
    });

    /* Force initial check if images should appear. */
    //PATCH: NAMESPACE
    $(document).bind("ready.lazyload" + D3ID, function () {
      update(); //event
    });

    //PATCH: NAMESPACE
    //trick - i plugin vengono attivati allo scroll. Sulle interazioni (toggle ad esempio) 
    //compaiono/scompaiono pezzi di dom e i lazy non si attivano
    $(document).bind("ready.lazyload" + D3ID, function () {
      $('body').bind("click.lazyload" + D3ID, function () {
        update(); //event
      });
    });

    //PATCH: TRICK
    //al load di una nuova porzione html scateno un update
    $(document)
    .bind("ajaxStop.lazyload" + D3ID, function () {
      update(); //event
    });
    return this;
  };

  /* Convenience methods in jQuery namespace.           */
  /* Use as  $.belowthefold(element, {threshold : 100, container : window}) */

  $.belowthefold = function (element, settings) {
    var fold;

    if (settings.container === undefined || settings.container === window) {
      fold = $win.height() + $win.scrollTop();
    } else {
      fold = $(settings.container).offset().top + $(settings.container).height();
    }

    return fold <= $(element).offset().top - settings.threshold;
  };

  $.rightoffold = function (element, settings) {
    var fold;

    if (settings.container === undefined || settings.container === window) {
      fold = $win.width() + $win.scrollLeft();
    } else {
      fold = $(settings.container).offset().left + $(settings.container).width();
    }

    return fold <= $(element).offset().left - settings.threshold;
  };

  $.abovethetop = function (element, settings) {
    var fold;

    if (settings.container === undefined || settings.container === window) {
      fold = $win.scrollTop();
    } else {
      fold = $(settings.container).offset().top;
    }

    return fold >= $(element).offset().top + settings.threshold + $(element).height();
  };

  $.leftofbegin = function (element, settings) {
    var fold;

    if (settings.container === undefined || settings.container === window) {
      fold = $win.scrollLeft();
    } else {
      fold = $(settings.container).offset().left;
    }

    return fold >= $(element).offset().left + settings.threshold + $(element).width();
  };

  $.inviewport = function (element, settings) {
    return !$.rightoffold(element, settings) && !$.leftofbegin(element, settings) &&
                !$.belowthefold(element, settings) && !$.abovethetop(element, settings);
  };

  /* Custom selectors for your convenience.   */
  /* Use as $("img:below-the-fold").something() or */
  /* $("img").filter(":below-the-fold").something() which is faster */

  $.extend($.expr[':'], {
    "below-the-fold": function (a) { return $.belowthefold(a, { threshold: 0 }); },
    "above-the-top": function (a) { return !$.belowthefold(a, { threshold: 0 }); },
    "right-of-screen": function (a) { return $.rightoffold(a, { threshold: 0 }); },
    "left-of-screen": function (a) { return !$.rightoffold(a, { threshold: 0 }); },
    "in-viewport": function (a) { return $.inviewport(a, { threshold: 0 }); },
    /* Maintain BC for couple of versions. */
    "above-the-fold": function (a) { return !$.belowthefold(a, { threshold: 0 }); },
    "right-of-fold": function (a) { return $.rightoffold(a, { threshold: 0 }); },
    "left-of-fold": function (a) { return !$.rightoffold(a, { threshold: 0 }); }
  });



} (jQuery, window));
;/* exclude for JSLint parsing */
/*global window, document, navigator, console, jQuery, deltatre, FB, location, tzc */



(function($, win) {


  'use strict';

  
  var d3 = win.Deltatre;
  var p3 = d3.plugins;
  var trace = d3.Trace;
  var core = d3.core.getInstance();


  $(document).ready(function() {

    try {

      //Launch Plugins on all page
      var $el = document;

      //tracking elements on the footer - speed up parsing and launch
      //core.launchPlugins($el, '.d3-tracking');

      core.launchPlugins($el, '.d3-plugin');

    } catch (e) {
      trace(e);
      trace('core function error');
    }
  });



} (jQuery, window));

;
;